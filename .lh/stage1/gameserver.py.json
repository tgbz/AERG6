{
    "sourceFile": "stage1/gameserver.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 33,
            "patches": [
                {
                    "date": 1652458448350,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1652458595126,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,31 @@\n+import socket, threading, time, sys, pickle, random, time, sys\n+\n+\n+\n+clients = dict()\n+maxPlayersForGame = 2\n+totalReadyPlayers = 0\n+\n+\n+class controlHandler(threading.Thread):\n+    def __init__(self):\n+        threading.Thread.__init__(self)\n+        global clients\n+        global totalReadyPlayers\n+        self.controlPort = 8080\n+        self.hostName = socket.gethostname()\n+        self.buffer = 2048\n+        \n+    def addClient(self,addr,port):\n+        if addr not in clients.keys():\n+            if addr not in clients.keys():\n+                clients[addr] = {\n+                \"port\": port,\n+                \"ready\": 0,\n+                \"ingame\": 0,\n+                \"online\": 1\n+            }\n+            print(\"Cliente \" + str(addr) + \" adicionado\")\n+        else:\n+            print(\"Cliente \" + str(addr) + \" já existe\")\n+        return clients[addr]\n\\ No newline at end of file\n"
                },
                {
                    "date": 1652458693940,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -14,9 +14,11 @@\n         global totalReadyPlayers\n         self.controlPort = 8080\n         self.hostName = socket.gethostname()\n         self.buffer = 2048\n-        \n+   \n+    #Funcao Utilitaria que adiciona o cliente, utilizando o endereço ipv6 como chave.\n+    #Caso ele já exista, não faz nada.    \n     def addClient(self,addr,port):\n         if addr not in clients.keys():\n             if addr not in clients.keys():\n                 clients[addr] = {\n@@ -27,5 +29,17 @@\n             }\n             print(\"Cliente \" + str(addr) + \" adicionado\")\n         else:\n             print(\"Cliente \" + str(addr) + \" já existe\")\n-        return clients[addr]\n\\ No newline at end of file\n+        return clients[addr]\n+    #Funcao utilitaria que remove um dado cliente da lista de clientes.\n+    def removeClient(self,addr):\n+        if addr in clients.keys():\n+            clients.pop(addr)\n+            print(\"Cliente \" + str(addr) + \" removido\")\n+        else:\n+            print(\"Cliente \" + str(addr) + \" não encontrado\")\n+    #Funcao utilitaria que devolve o endereço de um dado cliente.\n+    def getClient(self,addr):\n+        if addr in clients.keys():\n+            return clients[addr]\n+        \n\\ No newline at end of file\n"
                },
                {
                    "date": 1652458756547,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -6,13 +6,11 @@\n maxPlayersForGame = 2\n totalReadyPlayers = 0\n \n \n-class controlHandler(threading.Thread):\n+class networkStatusHandler(threading.Thread):\n     def __init__(self):\n         threading.Thread.__init__(self)\n-        global clients\n-        global totalReadyPlayers\n         self.controlPort = 8080\n         self.hostName = socket.gethostname()\n         self.buffer = 2048\n    \n@@ -41,5 +39,11 @@\n     #Funcao utilitaria que devolve o endereço de um dado cliente.\n     def getClient(self,addr):\n         if addr in clients.keys():\n             return clients[addr]\n-        \n\\ No newline at end of file\n+        else:\n+            print(\"Cliente nao encontrado\")\n+            return None\n+    \n+    def run(self):\n+        global totalReadyPlayers\n+        print(\"I\")\n\\ No newline at end of file\n"
                },
                {
                    "date": 1652458850331,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -12,8 +12,9 @@\n         threading.Thread.__init__(self)\n         self.controlPort = 8080\n         self.hostName = socket.gethostname()\n         self.buffer = 2048\n+        self.mcastAddr = \"FF01:0:0:0:0:0:0:1\"\n    \n     #Funcao Utilitaria que adiciona o cliente, utilizando o endereço ipv6 como chave.\n     #Caso ele já exista, não faz nada.    \n     def addClient(self,addr,port):\n@@ -45,5 +46,12 @@\n             return None\n     \n     def run(self):\n         global totalReadyPlayers\n-        print(\"I\")\n\\ No newline at end of file\n+        print(\"Thread de gestao de utilizadores inicialziada\")\n+        #bind the socket para ipv6\n+        self.port = 8080\n+        self.hostName = socket.gethostname()\n+        self.socket = socket.socket(socket.AF_INET6, socket.SOCK_DGRAM)\n+        self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n+        self.socket.bind(('', self.port))\n+        \n\\ No newline at end of file\n"
                },
                {
                    "date": 1652459320933,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -26,11 +26,12 @@\n                 \"ingame\": 0,\n                 \"online\": 1\n             }\n             print(\"Cliente \" + str(addr) + \" adicionado\")\n+            return 1\n         else:\n             print(\"Cliente \" + str(addr) + \" já existe\")\n-        return clients[addr]\n+            return 0 \n     #Funcao utilitaria que remove um dado cliente da lista de clientes.\n     def removeClient(self,addr):\n         if addr in clients.keys():\n             clients.pop(addr)\n@@ -53,5 +54,14 @@\n         self.hostName = socket.gethostname()\n         self.socket = socket.socket(socket.AF_INET6, socket.SOCK_DGRAM)\n         self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n         self.socket.bind(('', self.port))\n-        \n\\ No newline at end of file\n+        #Incializaçaõ de loop para gestao de users:\n+        while True:\n+            data, addr = self.socket.recvfrom(self.buffer)\n+            data = data.decode()\n+            #Cases para a receção de dados:\n+            \n+            if data.split('-')[0]==\"new\":\n+                print(\"Nova conexao de \" + str(data.split('-')[1]))\n+                \n+                \n\\ No newline at end of file\n"
                },
                {
                    "date": 1652459517740,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -62,6 +62,11 @@\n             #Cases para a receção de dados:\n             \n             if data.split('-')[0]==\"new\":\n                 print(\"Nova conexao de \" + str(data.split('-')[1]))\n-                \n+                if self.addClient(addr,addr[1])==1:\n+                    print(\"Cliente adicionado\"  + str(addr))\n+                    print(\"Estado actual dos clientes:\")\n+                    print(clients)\n+                    print(\"A enviar confirmação para os clientes:\")\n+                    self.socket.sendto(bytes((\"hello-%s-%s\"),addr[0],self.mcastAddr),addr)\n                 \n\\ No newline at end of file\n"
                },
                {
                    "date": 1652459718688,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -68,5 +68,13 @@\n                     print(\"Estado actual dos clientes:\")\n                     print(clients)\n                     print(\"A enviar confirmação para os clientes:\")\n                     self.socket.sendto(bytes((\"hello-%s-%s\"),addr[0],self.mcastAddr),addr)\n+                    print(\"Endereço Multicast Enviado\")\n+            elif data.split('-')[0]==\"mcast-ok\":\n+                #verificar se o cliente já está na lista de clientes\n+                if clients[addr[0]] is not None:\n+                    print(\"confirmação de recepção de multicast recebida de \" + str(addr[0]))\n+                    \n+                else:\n+                    print(\"Cliente não está autenticado... A descartar...\")\n                 \n\\ No newline at end of file\n"
                },
                {
                    "date": 1652459979140,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -45,8 +45,22 @@\n         else:\n             print(\"Cliente nao encontrado\")\n             return None\n     \n+    #Funcao utilitaria que actualiza o estado de um dado cliente para online\n+    def setClientOnline(self,addr):\n+        if addr in clients.keys():\n+            clients[addr][\"online\"] = 1\n+        else:\n+            print(\"Cliente nao encontrado\")\n+    #Funcao utilitaria que actualiza o estado de um dado cliente para pronto\n+    def setClientReady(self,addr):\n+        global totalReadyPlayers\n+        if addr in clients.keys():\n+            clients[addr][\"ready\"] = 1\n+            totalReadyPlayers += 1\n+            \n+    \n     def run(self):\n         global totalReadyPlayers\n         print(\"Thread de gestao de utilizadores inicialziada\")\n         #bind the socket para ipv6\n@@ -73,8 +87,13 @@\n             elif data.split('-')[0]==\"mcast-ok\":\n                 #verificar se o cliente já está na lista de clientes\n                 if clients[addr[0]] is not None:\n                     print(\"confirmação de recepção de multicast recebida de \" + str(addr[0]))\n-                    \n+                    print(\"A atualizar o seu estado para online\")\n+                    self.setClientOnline(addr[0])\n+                    self.socket.sendto(bytes((\"ready?-%s\"),addr[0]),addr)\n                 else:\n                     print(\"Cliente não está autenticado... A descartar...\")\n+            elif data.split('-')[0]==\"readyOk\":\n+                print(\"cliente \" + str(addr[0]) + \" está pronto\")\n+                print(\"Estado actualizado dos clientes\")\n                 \n\\ No newline at end of file\n"
                },
                {
                    "date": 1652461364018,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,5 +1,5 @@\n-import socket, threading, time, sys, pickle, random, time, sys\n+import socket, threading, time, sys, pickle, random, time, sys, json\n \n \n \n clients = dict()\n@@ -95,5 +95,61 @@\n                     print(\"Cliente não está autenticado... A descartar...\")\n             elif data.split('-')[0]==\"readyOk\":\n                 print(\"cliente \" + str(addr[0]) + \" está pronto\")\n                 print(\"Estado actualizado dos clientes\")\n-                \n\\ No newline at end of file\n+            \n+            elif data.split('-')[0]==\"disconnect\":\n+                print(\"A remover cliente \" + str(addr[0]))\n+                self.removeClient(addr[0])\n+                            \n+            \n+class hearbeatHandler(threading.Thread):\n+    #Funcao que inicializa a thread de heartbeat\n+    def __init__(self):\n+        threading.Thread.__init__(self)\n+        self.controlPort = 8081\n+        self.hostName = socket.gethostname()\n+        self.buffer = 2048\n+        \n+    #Funcao que envia um heartbeat para todos os clientes\n+    def sendHeartbeat(self):\n+        for addr in clients.keys():\n+            self.socket.sendto(bytes((\"heartbeat-%s\"),addr),addr)\n+            print(\"Heartbeat enviado para \" + str(addr))\n+    #Funcao que recebe um heartbeat de todos os clientes num espaço de 10 segundos, o seu estado é actualizado para online = 0\n+    def receiveHeartbeat(self):\n+        while True:\n+            data, addr = self.socket.recvfrom(self.buffer)\n+            data = data.decode()\n+            if data.split('-')[0]==\"heartbeat\":\n+                print(\"Heartbeat recebido de \" + str(addr))\n+                self.setClientOnline(addr[0])\n+            time.sleep(10)\n+            #Verificar se há clientes offline\n+            for addr in clients.keys():\n+                if clients[addr][\"online\"]==0:\n+                    print(\"Cliente \" + str(addr) + \" offline\")\n+    #Funcao que actualiza o estado de um dado cliente para offline\n+    \n+    #Funcao que inicializa a thread de heartbeat\n+    def run(self):\n+        print(\"Thread de heartbeat inicializada\")\n+        #bind the socket para ipv6\n+        self.socket = socket.socket(socket.AF_INET6, socket.SOCK_DGRAM)\n+        self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n+        self.socket.bind(('', self.port))\n+        #Incialização de loop para gestao de heartbeat\n+        while True:\n+            self.sendHeartbeat()\n+            self.receiveHeartbeat()\n+            time.sleep(10)\n+    \n+\n+\"\"\"\n+Thread para gestão do jogo, que inicializa o jogo e o envio das músicas assim como as opções de jogo para todos os clientes via mutlicast.        \n+\"\"\"\n+class Game(threading.Thread):\n+    def __init__(self):\n+        threading.Thread.__init__(self)\n+        self.songDB = \"songlist.json\"\n+        self.songList = json.load(open(self.songDB))\n+        \n\\ No newline at end of file\n"
                },
                {
                    "date": 1652462354841,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,10 +4,10 @@\n \n clients = dict()\n maxPlayersForGame = 2\n totalReadyPlayers = 0\n+maxGameRounds = 3\n \n-\n class networkStatusHandler(threading.Thread):\n     def __init__(self):\n         threading.Thread.__init__(self)\n         self.controlPort = 8080\n@@ -151,5 +151,23 @@\n     def __init__(self):\n         threading.Thread.__init__(self)\n         self.songDB = \"songlist.json\"\n         self.songList = json.load(open(self.songDB))\n-        \n\\ No newline at end of file\n+        self.mCastSocket = socket.socket(socket.AF_INET6, socket.SOCK_DGRAM)\n+        self.mCastSocket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n+        self.mCastSocket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEPORT, 1)\n+        self.mCastSocket.setsockopt(socket.IPPROTO_IPV6, socket.IPV6_MULTICAST_HOPS,5)\n+        self.mCastSocket.setsockopt(socket.IPPROTO_IPV6, socket.IPV6_MULTICAST_LOOP,1)\n+        self.mCastSocket.setsockopt(socket.IPPROTO_IPV6, socket.IPV6_MULTICAST_HOPS, 100)\n+        self.mcastPort = 8888\n+        self.mcastAddr = \"FF02::1\"\n+        self.buffer = 2048\n+        \n+        self.currentGameNumberOfPlayers = 0\n+        \n+        \n+    def generateGame(self):\n+        song = str(random.randint(1,len(self.songList)))\n+        \n+    def generateOptions(self):\n+        options = []\n+        maxOptions = \n\\ No newline at end of file\n"
                },
                {
                    "date": 1652462854400,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -162,12 +162,26 @@\n         self.mcastAddr = \"FF02::1\"\n         self.buffer = 2048\n         \n         self.currentGameNumberOfPlayers = 0\n-        \n-        \n+    \n+    #Função que escolhe ids de músicas aleatórias da base da dados disponível   \n+    def generateOptions(self):\n+        global maxGameRounds\n+        options = []\n+        maxOptions = maxGameRounds\n\\ No newline at end of file\n+        while len(options)<maxOptions:\n+            option = str(random.randint(1,len(self.songList)))\n+            if option not in options:\n+                options.append(option)\n+        return options\n+    \n+    #\n+    \n     def generateGame(self):\n         song = str(random.randint(1,len(self.songList)))\n+        options = self.generateOptions()\n+        print(\"Músicas escolhidas:\")\n+        for option in options:\n+            print(self.songList[option][\"title\"])\n         \n-    def generateOptions(self):\n-        options = []\n-        maxOptions = \n+    \n"
                },
                {
                    "date": 1652463021989,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -164,9 +164,9 @@\n         \n         self.currentGameNumberOfPlayers = 0\n     \n     #Função que escolhe ids de músicas aleatórias da base da dados disponível   \n-    def generateOptions(self):\n+    def chooseSongs(self):\n         global maxGameRounds\n         options = []\n         maxOptions = maxGameRounds\n         while len(options)<maxOptions:\n@@ -174,14 +174,22 @@\n             if option not in options:\n                 options.append(option)\n         return options\n     \n-    #\n-    \n+    \"\"\"Funcao que escolhe para cada elemento da lista de opções de músicas, vai à base de dados e escolhe 3 outras músicas aleatórias, consistindo um grupo de escolhas nos seguinte formato:\n+        1 - <artist> - <tittle>\n+        2 - <artist> - <tittle>\n+        3 - <artist> - <tittle>\n+        4 - <artist> - <tittle>\n+    \"\"\"\n+    def generateOptions(self, options):\n+        \n\\ No newline at end of file\n+        \n+        \n     def generateGame(self):\n         song = str(random.randint(1,len(self.songList)))\n-        options = self.generateOptions()\n+        options = self.chooseOptions()\n         print(\"Músicas escolhidas:\")\n         for option in options:\n             print(self.songList[option][\"title\"])\n         \n-    \n+    \n"
                },
                {
                    "date": 1652463642464,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,5 +1,5 @@\n-import socket, threading, time, sys, pickle, random, time, sys, json\n+import socket, threading, time, sys, pickle, random, time, sys, json, Sender\n \n \n \n clients = dict()\n@@ -174,22 +174,51 @@\n             if option not in options:\n                 options.append(option)\n         return options\n     \n-    \"\"\"Funcao que escolhe para cada elemento da lista de opções de músicas, vai à base de dados e escolhe 3 outras músicas aleatórias, consistindo um grupo de escolhas nos seguinte formato:\n-        1 - <artist> - <tittle>\n-        2 - <artist> - <tittle>\n-        3 - <artist> - <tittle>\n-        4 - <artist> - <tittle>\n+    \"\"\"Funcao que escolhe para cada elemento da lista de opções de músicas, vai à base de dados e escolhe 3 outras músicas aleatórias, consistindo um dicionário de escolhas nos seguinte formato:\n+        rounds = {\n+                    \"1\": {\n+                        \"1\": \"<artist>-<song>\",   \n+                        \"2\": \"<artist>-<song>\",\n+                        \"3\": \"<artist>-<song>\",\n+                        \"4\": \"<artist>-<song>\",\n+                        },\n+                    \"2\": {\n+                        \"1\": \"<artist>-<song>\",\n+                        \"2\": \"<artist>-<song>\",\n+                        \"3\": \"<artist>-<song>\",\n+                        \"4\": \"<artist>-<song>\",\n\\ No newline at end of file\n+                        },\n+                        ...\n+                    }\n     \"\"\"\n-    def generateOptions(self, options):\n+    def generateOptions(self, options, numberOfRounds):\n+        rounds = {}\n+        for i in range(numberOfRounds):\n+            rounds[str(i+1)] = {}\n+            for j in range(4):\n+                rounds[str(i+1)][str(j+1)] = self.songList[options[i]][\"artist\"] + \"-\" + self.songList[options[i]][\"song\"]\n+                options.remove(options[i])\n+                for k in range(3):\n+                    option = str(random.randint(1,len(self.songList)))\n+                    if option not in options:\n+                        options.append(option)\n+                    rounds[str(i+1)][str(j+1+k+1)] = self.songList[option][\"artist\"] + \"-\" + self.songList[option][\"song\"]\n+        return rounds\n         \n-        \n-        \n     def generateGame(self):\n-        song = str(random.randint(1,len(self.songList)))\n         options = self.chooseOptions()\n         print(\"Músicas escolhidas:\")\n         for option in options:\n             print(self.songList[option][\"title\"])\n-        \n-    \n+        print(\"Opções de jogo:\")\n+        rounds = self.generateOptions(options, maxGameRounds)\n+        print(rounds)\n+        filePaths = []\n+        for option in options:\n+            #get all the filePaths of the songs\n+            filePaths.append(self.songList[option][\"filePath\"])\n+        print(\"Procedendo ao envio das músicas...\")\n+        for i in range(len(filePaths)):\n+            print(\"A enviar música \" + str(i+1) + \" de \" + str(len(filePaths)))\n+            sen = Sender.Sender()\n"
                },
                {
                    "date": 1652463980005,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -160,8 +160,12 @@\n         self.mCastSocket.setsockopt(socket.IPPROTO_IPV6, socket.IPV6_MULTICAST_HOPS, 100)\n         self.mcastPort = 8888\n         self.mcastAddr = \"FF02::1\"\n         self.buffer = 2048\n+        self.controlSocket = socket.socket(socket.AF_INET6, socket.SOCK_DGRAM)\n+        self.controlPort = 8081\n+        self.controlSocket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n+        self.controlSocket.bind(('', self.controlPort))\n         \n         self.currentGameNumberOfPlayers = 0\n     \n     #Função que escolhe ids de músicas aleatórias da base da dados disponível   \n@@ -206,19 +210,31 @@\n                     rounds[str(i+1)][str(j+1+k+1)] = self.songList[option][\"artist\"] + \"-\" + self.songList[option][\"song\"]\n         return rounds\n         \n     def generateGame(self):\n-        options = self.chooseOptions()\n+        global totalReadyPlayers\n+        gameSongs = self.chooseOptions()\n         print(\"Músicas escolhidas:\")\n         for option in options:\n             print(self.songList[option][\"title\"])\n         print(\"Opções de jogo:\")\n-        rounds = self.generateOptions(options, maxGameRounds)\n+        rounds = self.generateOptions(gameSongs, maxGameRounds)\n         print(rounds)\n         filePaths = []\n-        for option in options:\n+        recvCounter = 0\n+        for option in gameSongs:\n             #get all the filePaths of the songs\n\\ No newline at end of file\n             filePaths.append(self.songList[option][\"filePath\"])\n         print(\"Procedendo ao envio das músicas...\")\n         for i in range(len(filePaths)):\n             print(\"A enviar música \" + str(i+1) + \" de \" + str(len(filePaths)))\n-            sen = Sender.Sender()\n+            sen = Sender.Sender(self.mcastAddr,self.mcastPort,filePaths[i],self.mCastSocket)\n+            while recvCounter <= totalReadyPlayers:\n+                data, addr = self.socket.recvfrom(self.buffer)\n+                data = data.decode()\n+                if data.split('-')[0] == \"songReceiveOk\":\n+                    recvCounter+=1\n+                    print(\"Música \" + str(i+1) + \" enviada e confirmada\")\n+        print(\"Músicas enviadas\")\n+        for i in range(totalReadyPlayers):\n+            print(\"A enviar opções de jogo...\")\n+            \n"
                },
                {
                    "date": 1652464001529,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -233,8 +233,10 @@\n                 data = data.decode()\n                 if data.split('-')[0] == \"songReceiveOk\":\n                     recvCounter+=1\n                     print(\"Música \" + str(i+1) + \" enviada e confirmada\")\n+            recvCounter = 0\n         print(\"Músicas enviadas\")\n         for i in range(totalReadyPlayers):\n             print(\"A enviar opções de jogo...\")\n\\ No newline at end of file\n-            \n+            sen = Sender.Sender(self.mcastAddr,self.mcastPort,json.dumps(rounds),self.mCastSocket)\n+            while \n"
                },
                {
                    "date": 1652464094727,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -228,15 +228,21 @@\n         for i in range(len(filePaths)):\n             print(\"A enviar música \" + str(i+1) + \" de \" + str(len(filePaths)))\n             sen = Sender.Sender(self.mcastAddr,self.mcastPort,filePaths[i],self.mCastSocket)\n             while recvCounter <= totalReadyPlayers:\n-                data, addr = self.socket.recvfrom(self.buffer)\n+                data, addr = self.controlSocket.recvfrom(self.buffer)\n                 data = data.decode()\n                 if data.split('-')[0] == \"songReceiveOk\":\n                     recvCounter+=1\n                     print(\"Música \" + str(i+1) + \" enviada e confirmada\")\n             recvCounter = 0\n         print(\"Músicas enviadas\")\n-        for i in range(totalReadyPlayers):\n-            print(\"A enviar opções de jogo...\")\n-            sen = Sender.Sender(self.mcastAddr,self.mcastPort,json.dumps(rounds),self.mCastSocket)\n\\ No newline at end of file\n-            while \n+        print(\"A enviar opções de jogo...\")\n+        sen = Sender.Sender(self.mcastAddr,self.mcastPort,json.dumps(rounds),self.mCastSocket)\n+        while recvCounter <= totalReadyPlayers:\n+            data, addr = self.controlSocket.recvfrom(self.buffer)\n+            data = data.decode()\n+            if data.split('-')[0] == \"roundsReceiveOk\":\n+                recvCounter+=1\n+                print(\"Opções de jogo enviadas e confirmadas\")\n+        recvCounter = 0\n+        print(\"Opções de jogo enviadas\")\n"
                },
                {
                    "date": 1652465672212,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -245,4 +245,23 @@\n                 recvCounter+=1\n                 print(\"Opções de jogo enviadas e confirmadas\")\n         recvCounter = 0\n         print(\"Opções de jogo enviadas\")\n+        print(\"A iniciar o jogo...\")\n+        self.currentGameNumberOfPlayers = totalReadyPlayers\n+        self.mCastSocket.sendto(\"gameStart\".encode(),(self.mcastAddr,self.mcastPort))\n+        while recvCounter <= self.currentGameNumberOfPlayers:\n+            data, addr = self.controlSocket.recvfrom(self.buffer)\n+            data = data.decode()\n+            if data.split('-')[0] == \"gameStartOk\":\n+                recvCounter+=1\n+                print(\"Jogo iniciado\")\n+        recvCounter = 0\n+        print(\"À espera de submissão das músicas...\")\n+        playersAnswers = dict()\n+        while recvCounter <= self.currentGameNumberOfPlayers:\n+            data, addr = self.controlSocket.recvfrom(self.buffer)\n+            data = data.decode()\n+            if data.split('-')[0] == \"playerAnswer\":\n+                playersAnswers[addr[0]]=data.split('-')[1]+\"-\"+data.split('-')[2]+\"-\"+data.split('-')[3]\n+                recvCounter+=1\n+        print(\"Submissões recebidas\")\n\\ No newline at end of file\n"
                },
                {
                    "date": 1652466292815,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -208,9 +208,9 @@\n                     if option not in options:\n                         options.append(option)\n                     rounds[str(i+1)][str(j+1+k+1)] = self.songList[option][\"artist\"] + \"-\" + self.songList[option][\"song\"]\n         return rounds\n-        \n+    \n     def generateGame(self):\n         global totalReadyPlayers\n         gameSongs = self.chooseOptions()\n         print(\"Músicas escolhidas:\")\n@@ -263,5 +263,6 @@\n             data = data.decode()\n             if data.split('-')[0] == \"playerAnswer\":\n                 playersAnswers[addr[0]]=data.split('-')[1]+\"-\"+data.split('-')[2]+\"-\"+data.split('-')[3]\n                 recvCounter+=1\n-        print(\"Submissões recebidas\")\n\\ No newline at end of file\n+        print(\"Submissões recebidas\")\n+        \n\\ No newline at end of file\n"
                },
                {
                    "date": 1652466682984,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -263,6 +263,7 @@\n             data = data.decode()\n             if data.split('-')[0] == \"playerAnswer\":\n                 playersAnswers[addr[0]]=data.split('-')[1]+\"-\"+data.split('-')[2]+\"-\"+data.split('-')[3]\n                 recvCounter+=1\n-        print(\"Submissões recebidas\")\n+        print(\"Submissões recebidas:\")\n+        print(playersAnswers)\n         \n\\ No newline at end of file\n"
                },
                {
                    "date": 1652466696900,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -261,9 +261,9 @@\n         while recvCounter <= self.currentGameNumberOfPlayers:\n             data, addr = self.controlSocket.recvfrom(self.buffer)\n             data = data.decode()\n             if data.split('-')[0] == \"playerAnswer\":\n-                playersAnswers[addr[0]]=data.split('-')[1]+\"-\"+data.split('-')[2]+\"-\"+data.split('-')[3]\n+                playersAnswers[addr[0]]=data.split('-')[1]+\"-\"+data.split('-')[2]+\"-\"+data.split('-')[3]+\"-\"+data.split('-')[4]\n                 recvCounter+=1\n         print(\"Submissões recebidas:\")\n         print(playersAnswers)\n         \n\\ No newline at end of file\n"
                },
                {
                    "date": 1652466720310,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -257,8 +257,11 @@\n                 print(\"Jogo iniciado\")\n         recvCounter = 0\n         print(\"À espera de submissão das músicas...\")\n         playersAnswers = dict()\n+        \"\"\"\n+    \n+        \"\"\"\n         while recvCounter <= self.currentGameNumberOfPlayers:\n             data, addr = self.controlSocket.recvfrom(self.buffer)\n             data = data.decode()\n             if data.split('-')[0] == \"playerAnswer\":\n"
                },
                {
                    "date": 1652466738264,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -258,8 +258,11 @@\n         recvCounter = 0\n         print(\"À espera de submissão das músicas...\")\n         playersAnswers = dict()\n         \"\"\"\n+        playersAnswers = {\n+                        1: {\n+                            <round>: {\n     \n         \"\"\"\n         while recvCounter <= self.currentGameNumberOfPlayers:\n             data, addr = self.controlSocket.recvfrom(self.buffer)\n"
                },
                {
                    "date": 1652466745022,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -260,9 +260,9 @@\n         playersAnswers = dict()\n         \"\"\"\n         playersAnswers = {\n                         1: {\n-                            <round>: {\n+                            <round>: { \"choice\": \"\n     \n         \"\"\"\n         while recvCounter <= self.currentGameNumberOfPlayers:\n             data, addr = self.controlSocket.recvfrom(self.buffer)\n"
                },
                {
                    "date": 1652466753993,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -260,9 +260,11 @@\n         playersAnswers = dict()\n         \"\"\"\n         playersAnswers = {\n                         1: {\n-                            <round>: { \"choice\": \"\n+                            <round>: { \"choice\": \"1\", \"time\": \"0.0\" },\n+                            <round>: { \"choice\": \"1\", \"time\": \"0.0\" },\n+                            <\n     \n         \"\"\"\n         while recvCounter <= self.currentGameNumberOfPlayers:\n             data, addr = self.controlSocket.recvfrom(self.buffer)\n"
                },
                {
                    "date": 1652466762776,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -262,9 +262,10 @@\n         playersAnswers = {\n                         1: {\n                             <round>: { \"choice\": \"1\", \"time\": \"0.0\" },\n                             <round>: { \"choice\": \"1\", \"time\": \"0.0\" },\n-                            <\n+                            <round>:    ...\n+                            }\n     \n         \"\"\"\n         while recvCounter <= self.currentGameNumberOfPlayers:\n             data, addr = self.controlSocket.recvfrom(self.buffer)\n"
                },
                {
                    "date": 1652466772138,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -260,10 +260,10 @@\n         playersAnswers = dict()\n         \"\"\"\n         playersAnswers = {\n                         1: {\n+                            <round>: { \"choice\": \"0\", \"time\": \"0.0\" },\n                             <round>: { \"choice\": \"1\", \"time\": \"0.0\" },\n-                            <round>: { \"choice\": \"1\", \"time\": \"0.0\" },\n                             <round>:    ...\n                             }\n     \n         \"\"\"\n"
                },
                {
                    "date": 1652466781838,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -259,11 +259,11 @@\n         print(\"À espera de submissão das músicas...\")\n         playersAnswers = dict()\n         \"\"\"\n         playersAnswers = {\n-                        1: {\n+                        <playerId>: {\n                             <round>: { \"choice\": \"0\", \"time\": \"0.0\" },\n-                            <round>: { \"choice\": \"1\", \"time\": \"0.0\" },\n+                            <round>: { \"choice\": \"0\", \"time\": \"0.0\" },\n                             <round>:    ...\n                             }\n     \n         \"\"\"\n"
                },
                {
                    "date": 1652466837021,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -9,9 +9,8 @@\n \n class networkStatusHandler(threading.Thread):\n     def __init__(self):\n         threading.Thread.__init__(self)\n-        self.controlPort = 8080\n         self.hostName = socket.gethostname()\n         self.buffer = 2048\n         self.mcastAddr = \"FF01:0:0:0:0:0:0:1\"\n    \n"
                },
                {
                    "date": 1652466868000,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -72,9 +72,11 @@\n         while True:\n             data, addr = self.socket.recvfrom(self.buffer)\n             data = data.decode()\n             #Cases para a receção de dados:\n-            \n+            \"\"\"\n+            1\n+            \"\"\"\n             if data.split('-')[0]==\"new\":\n                 print(\"Nova conexao de \" + str(data.split('-')[1]))\n                 if self.addClient(addr,addr[1])==1:\n                     print(\"Cliente adicionado\"  + str(addr))\n"
                },
                {
                    "date": 1652466884647,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -73,9 +73,10 @@\n             data, addr = self.socket.recvfrom(self.buffer)\n             data = data.decode()\n             #Cases para a receção de dados:\n             \"\"\"\n-            1\n+            1 - Cliente envia mensagem new-addr\n+            2 - Servidor responde com hello-addr-mcastAddr\n             \"\"\"\n             if data.split('-')[0]==\"new\":\n                 print(\"Nova conexao de \" + str(data.split('-')[1]))\n                 if self.addClient(addr,addr[1])==1:\n"
                },
                {
                    "date": 1652467050010,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -75,8 +75,13 @@\n             #Cases para a receção de dados:\n             \"\"\"\n             1 - Cliente envia mensagem new-addr\n             2 - Servidor responde com hello-addr-mcastAddr\n+            3 - Cliente envia mensagem de confirmação de mcastAddr\n+            4 - Servidor envia mensagem com ready?\n+            5 - Cliente responde com readyOk\n+            7 - Servidor entra em loop de hearbeat (e cliente associado)\n+            8 - Cliente envia mensagem de disconnect opcional quando quiser.\n             \"\"\"\n             if data.split('-')[0]==\"new\":\n                 print(\"Nova conexao de \" + str(data.split('-')[1]))\n                 if self.addClient(addr,addr[1])==1:\n@@ -97,8 +102,9 @@\n                     print(\"Cliente não está autenticado... A descartar...\")\n             elif data.split('-')[0]==\"readyOk\":\n                 print(\"cliente \" + str(addr[0]) + \" está pronto\")\n                 print(\"Estado actualizado dos clientes\")\n+                self.setClientReady(addr[0])\n             \n             elif data.split('-')[0]==\"disconnect\":\n                 print(\"A remover cliente \" + str(addr[0]))\n                 self.removeClient(addr[0])\n"
                },
                {
                    "date": 1652467279355,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -6,8 +6,25 @@\n maxPlayersForGame = 2\n totalReadyPlayers = 0\n maxGameRounds = 3\n \n+\"\"\" \n+clients : {\n+    <client_id> : {\n+        port : <port>,\n+        ready : <bool>,\n+        ingame : <bool>,\n+        online : <bool>,\n+    },\n+    <client_id> : {\n+        port : <port>,\n+        ready : <bool>,\n+        ingame : <bool>,\n+        online : <bool>,\n+    },\n+    ....\n+\"\"\"\n+\n class networkStatusHandler(threading.Thread):\n     def __init__(self):\n         threading.Thread.__init__(self)\n         self.hostName = socket.gethostname()\n@@ -221,9 +238,9 @@\n     def generateGame(self):\n         global totalReadyPlayers\n         gameSongs = self.chooseOptions()\n         print(\"Músicas escolhidas:\")\n-        for option in options:\n+        for option in gameOptions:\n             print(self.songList[option][\"title\"])\n         print(\"Opções de jogo:\")\n         rounds = self.generateOptions(gameSongs, maxGameRounds)\n         print(rounds)\n"
                },
                {
                    "date": 1652468547819,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -238,9 +238,9 @@\n     def generateGame(self):\n         global totalReadyPlayers\n         gameSongs = self.chooseOptions()\n         print(\"Músicas escolhidas:\")\n-        for option in gameOptions:\n+        for option in gameSongs:\n             print(self.songList[option][\"title\"])\n         print(\"Opções de jogo:\")\n         rounds = self.generateOptions(gameSongs, maxGameRounds)\n         print(rounds)\n@@ -289,15 +289,9 @@\n                             <round>: { \"choice\": \"0\", \"time\": \"0.0\" },\n                             <round>: { \"choice\": \"0\", \"time\": \"0.0\" },\n                             <round>:    ...\n                             }\n+        respostaplayer : <escolha>-<tempo>-<escolha>-<tempo>-<escolha>-<tempo> (nrounds)\n+        \"\"\"\n     \n-        \"\"\"\n-        while recvCounter <= self.currentGameNumberOfPlayers:\n-            data, addr = self.controlSocket.recvfrom(self.buffer)\n-            data = data.decode()\n-            if data.split('-')[0] == \"playerAnswer\":\n-                playersAnswers[addr[0]]=data.split('-')[1]+\"-\"+data.split('-')[2]+\"-\"+data.split('-')[3]+\"-\"+data.split('-')[4]\n-                recvCounter+=1\n-        print(\"Submissões recebidas:\")\n-        print(playersAnswers)\n+        \n         \n\\ No newline at end of file\n"
                }
            ],
            "date": 1652458448350,
            "name": "Commit-0",
            "content": ""
        }
    ]
}