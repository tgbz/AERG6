{
    "sourceFile": "stage1/gameserver.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 61,
            "patches": [
                {
                    "date": 1652458448350,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1652458595126,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,31 @@\n+import socket, threading, time, sys, pickle, random, time, sys\n+\n+\n+\n+clients = dict()\n+maxPlayersForGame = 2\n+totalReadyPlayers = 0\n+\n+\n+class controlHandler(threading.Thread):\n+    def __init__(self):\n+        threading.Thread.__init__(self)\n+        global clients\n+        global totalReadyPlayers\n+        self.controlPort = 8080\n+        self.hostName = socket.gethostname()\n+        self.buffer = 2048\n+        \n+    def addClient(self,addr,port):\n+        if addr not in clients.keys():\n+            if addr not in clients.keys():\n+                clients[addr] = {\n+                \"port\": port,\n+                \"ready\": 0,\n+                \"ingame\": 0,\n+                \"online\": 1\n+            }\n+            print(\"Cliente \" + str(addr) + \" adicionado\")\n+        else:\n+            print(\"Cliente \" + str(addr) + \" já existe\")\n+        return clients[addr]\n\\ No newline at end of file\n"
                },
                {
                    "date": 1652458693940,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -14,9 +14,11 @@\n         global totalReadyPlayers\n         self.controlPort = 8080\n         self.hostName = socket.gethostname()\n         self.buffer = 2048\n-        \n+   \n+    #Funcao Utilitaria que adiciona o cliente, utilizando o endereço ipv6 como chave.\n+    #Caso ele já exista, não faz nada.    \n     def addClient(self,addr,port):\n         if addr not in clients.keys():\n             if addr not in clients.keys():\n                 clients[addr] = {\n@@ -27,5 +29,17 @@\n             }\n             print(\"Cliente \" + str(addr) + \" adicionado\")\n         else:\n             print(\"Cliente \" + str(addr) + \" já existe\")\n-        return clients[addr]\n\\ No newline at end of file\n+        return clients[addr]\n+    #Funcao utilitaria que remove um dado cliente da lista de clientes.\n+    def removeClient(self,addr):\n+        if addr in clients.keys():\n+            clients.pop(addr)\n+            print(\"Cliente \" + str(addr) + \" removido\")\n+        else:\n+            print(\"Cliente \" + str(addr) + \" não encontrado\")\n+    #Funcao utilitaria que devolve o endereço de um dado cliente.\n+    def getClient(self,addr):\n+        if addr in clients.keys():\n+            return clients[addr]\n+        \n\\ No newline at end of file\n"
                },
                {
                    "date": 1652458756547,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -6,13 +6,11 @@\n maxPlayersForGame = 2\n totalReadyPlayers = 0\n \n \n-class controlHandler(threading.Thread):\n+class networkStatusHandler(threading.Thread):\n     def __init__(self):\n         threading.Thread.__init__(self)\n-        global clients\n-        global totalReadyPlayers\n         self.controlPort = 8080\n         self.hostName = socket.gethostname()\n         self.buffer = 2048\n    \n@@ -41,5 +39,11 @@\n     #Funcao utilitaria que devolve o endereço de um dado cliente.\n     def getClient(self,addr):\n         if addr in clients.keys():\n             return clients[addr]\n-        \n\\ No newline at end of file\n+        else:\n+            print(\"Cliente nao encontrado\")\n+            return None\n+    \n+    def run(self):\n+        global totalReadyPlayers\n+        print(\"I\")\n\\ No newline at end of file\n"
                },
                {
                    "date": 1652458850331,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -12,8 +12,9 @@\n         threading.Thread.__init__(self)\n         self.controlPort = 8080\n         self.hostName = socket.gethostname()\n         self.buffer = 2048\n+        self.mcastAddr = \"FF01:0:0:0:0:0:0:1\"\n    \n     #Funcao Utilitaria que adiciona o cliente, utilizando o endereço ipv6 como chave.\n     #Caso ele já exista, não faz nada.    \n     def addClient(self,addr,port):\n@@ -45,5 +46,12 @@\n             return None\n     \n     def run(self):\n         global totalReadyPlayers\n-        print(\"I\")\n\\ No newline at end of file\n+        print(\"Thread de gestao de utilizadores inicialziada\")\n+        #bind the socket para ipv6\n+        self.port = 8080\n+        self.hostName = socket.gethostname()\n+        self.socket = socket.socket(socket.AF_INET6, socket.SOCK_DGRAM)\n+        self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n+        self.socket.bind(('', self.port))\n+        \n\\ No newline at end of file\n"
                },
                {
                    "date": 1652459320933,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -26,11 +26,12 @@\n                 \"ingame\": 0,\n                 \"online\": 1\n             }\n             print(\"Cliente \" + str(addr) + \" adicionado\")\n+            return 1\n         else:\n             print(\"Cliente \" + str(addr) + \" já existe\")\n-        return clients[addr]\n+            return 0 \n     #Funcao utilitaria que remove um dado cliente da lista de clientes.\n     def removeClient(self,addr):\n         if addr in clients.keys():\n             clients.pop(addr)\n@@ -53,5 +54,14 @@\n         self.hostName = socket.gethostname()\n         self.socket = socket.socket(socket.AF_INET6, socket.SOCK_DGRAM)\n         self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n         self.socket.bind(('', self.port))\n-        \n\\ No newline at end of file\n+        #Incializaçaõ de loop para gestao de users:\n+        while True:\n+            data, addr = self.socket.recvfrom(self.buffer)\n+            data = data.decode()\n+            #Cases para a receção de dados:\n+            \n+            if data.split('-')[0]==\"new\":\n+                print(\"Nova conexao de \" + str(data.split('-')[1]))\n+                \n+                \n\\ No newline at end of file\n"
                },
                {
                    "date": 1652459517740,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -62,6 +62,11 @@\n             #Cases para a receção de dados:\n             \n             if data.split('-')[0]==\"new\":\n                 print(\"Nova conexao de \" + str(data.split('-')[1]))\n-                \n+                if self.addClient(addr,addr[1])==1:\n+                    print(\"Cliente adicionado\"  + str(addr))\n+                    print(\"Estado actual dos clientes:\")\n+                    print(clients)\n+                    print(\"A enviar confirmação para os clientes:\")\n+                    self.socket.sendto(bytes((\"hello-%s-%s\"),addr[0],self.mcastAddr),addr)\n                 \n\\ No newline at end of file\n"
                },
                {
                    "date": 1652459718688,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -68,5 +68,13 @@\n                     print(\"Estado actual dos clientes:\")\n                     print(clients)\n                     print(\"A enviar confirmação para os clientes:\")\n                     self.socket.sendto(bytes((\"hello-%s-%s\"),addr[0],self.mcastAddr),addr)\n+                    print(\"Endereço Multicast Enviado\")\n+            elif data.split('-')[0]==\"mcast-ok\":\n+                #verificar se o cliente já está na lista de clientes\n+                if clients[addr[0]] is not None:\n+                    print(\"confirmação de recepção de multicast recebida de \" + str(addr[0]))\n+                    \n+                else:\n+                    print(\"Cliente não está autenticado... A descartar...\")\n                 \n\\ No newline at end of file\n"
                },
                {
                    "date": 1652459979140,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -45,8 +45,22 @@\n         else:\n             print(\"Cliente nao encontrado\")\n             return None\n     \n+    #Funcao utilitaria que actualiza o estado de um dado cliente para online\n+    def setClientOnline(self,addr):\n+        if addr in clients.keys():\n+            clients[addr][\"online\"] = 1\n+        else:\n+            print(\"Cliente nao encontrado\")\n+    #Funcao utilitaria que actualiza o estado de um dado cliente para pronto\n+    def setClientReady(self,addr):\n+        global totalReadyPlayers\n+        if addr in clients.keys():\n+            clients[addr][\"ready\"] = 1\n+            totalReadyPlayers += 1\n+            \n+    \n     def run(self):\n         global totalReadyPlayers\n         print(\"Thread de gestao de utilizadores inicialziada\")\n         #bind the socket para ipv6\n@@ -73,8 +87,13 @@\n             elif data.split('-')[0]==\"mcast-ok\":\n                 #verificar se o cliente já está na lista de clientes\n                 if clients[addr[0]] is not None:\n                     print(\"confirmação de recepção de multicast recebida de \" + str(addr[0]))\n-                    \n+                    print(\"A atualizar o seu estado para online\")\n+                    self.setClientOnline(addr[0])\n+                    self.socket.sendto(bytes((\"ready?-%s\"),addr[0]),addr)\n                 else:\n                     print(\"Cliente não está autenticado... A descartar...\")\n+            elif data.split('-')[0]==\"readyOk\":\n+                print(\"cliente \" + str(addr[0]) + \" está pronto\")\n+                print(\"Estado actualizado dos clientes\")\n                 \n\\ No newline at end of file\n"
                },
                {
                    "date": 1652461364018,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,5 +1,5 @@\n-import socket, threading, time, sys, pickle, random, time, sys\n+import socket, threading, time, sys, pickle, random, time, sys, json\n \n \n \n clients = dict()\n@@ -95,5 +95,61 @@\n                     print(\"Cliente não está autenticado... A descartar...\")\n             elif data.split('-')[0]==\"readyOk\":\n                 print(\"cliente \" + str(addr[0]) + \" está pronto\")\n                 print(\"Estado actualizado dos clientes\")\n-                \n\\ No newline at end of file\n+            \n+            elif data.split('-')[0]==\"disconnect\":\n+                print(\"A remover cliente \" + str(addr[0]))\n+                self.removeClient(addr[0])\n+                            \n+            \n+class hearbeatHandler(threading.Thread):\n+    #Funcao que inicializa a thread de heartbeat\n+    def __init__(self):\n+        threading.Thread.__init__(self)\n+        self.controlPort = 8081\n+        self.hostName = socket.gethostname()\n+        self.buffer = 2048\n+        \n+    #Funcao que envia um heartbeat para todos os clientes\n+    def sendHeartbeat(self):\n+        for addr in clients.keys():\n+            self.socket.sendto(bytes((\"heartbeat-%s\"),addr),addr)\n+            print(\"Heartbeat enviado para \" + str(addr))\n+    #Funcao que recebe um heartbeat de todos os clientes num espaço de 10 segundos, o seu estado é actualizado para online = 0\n+    def receiveHeartbeat(self):\n+        while True:\n+            data, addr = self.socket.recvfrom(self.buffer)\n+            data = data.decode()\n+            if data.split('-')[0]==\"heartbeat\":\n+                print(\"Heartbeat recebido de \" + str(addr))\n+                self.setClientOnline(addr[0])\n+            time.sleep(10)\n+            #Verificar se há clientes offline\n+            for addr in clients.keys():\n+                if clients[addr][\"online\"]==0:\n+                    print(\"Cliente \" + str(addr) + \" offline\")\n+    #Funcao que actualiza o estado de um dado cliente para offline\n+    \n+    #Funcao que inicializa a thread de heartbeat\n+    def run(self):\n+        print(\"Thread de heartbeat inicializada\")\n+        #bind the socket para ipv6\n+        self.socket = socket.socket(socket.AF_INET6, socket.SOCK_DGRAM)\n+        self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n+        self.socket.bind(('', self.port))\n+        #Incialização de loop para gestao de heartbeat\n+        while True:\n+            self.sendHeartbeat()\n+            self.receiveHeartbeat()\n+            time.sleep(10)\n+    \n+\n+\"\"\"\n+Thread para gestão do jogo, que inicializa o jogo e o envio das músicas assim como as opções de jogo para todos os clientes via mutlicast.        \n+\"\"\"\n+class Game(threading.Thread):\n+    def __init__(self):\n+        threading.Thread.__init__(self)\n+        self.songDB = \"songlist.json\"\n+        self.songList = json.load(open(self.songDB))\n+        \n\\ No newline at end of file\n"
                },
                {
                    "date": 1652462354841,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,10 +4,10 @@\n \n clients = dict()\n maxPlayersForGame = 2\n totalReadyPlayers = 0\n+maxGameRounds = 3\n \n-\n class networkStatusHandler(threading.Thread):\n     def __init__(self):\n         threading.Thread.__init__(self)\n         self.controlPort = 8080\n@@ -151,5 +151,23 @@\n     def __init__(self):\n         threading.Thread.__init__(self)\n         self.songDB = \"songlist.json\"\n         self.songList = json.load(open(self.songDB))\n-        \n\\ No newline at end of file\n+        self.mCastSocket = socket.socket(socket.AF_INET6, socket.SOCK_DGRAM)\n+        self.mCastSocket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n+        self.mCastSocket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEPORT, 1)\n+        self.mCastSocket.setsockopt(socket.IPPROTO_IPV6, socket.IPV6_MULTICAST_HOPS,5)\n+        self.mCastSocket.setsockopt(socket.IPPROTO_IPV6, socket.IPV6_MULTICAST_LOOP,1)\n+        self.mCastSocket.setsockopt(socket.IPPROTO_IPV6, socket.IPV6_MULTICAST_HOPS, 100)\n+        self.mcastPort = 8888\n+        self.mcastAddr = \"FF02::1\"\n+        self.buffer = 2048\n+        \n+        self.currentGameNumberOfPlayers = 0\n+        \n+        \n+    def generateGame(self):\n+        song = str(random.randint(1,len(self.songList)))\n+        \n+    def generateOptions(self):\n+        options = []\n+        maxOptions = \n\\ No newline at end of file\n"
                },
                {
                    "date": 1652462854400,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -162,12 +162,26 @@\n         self.mcastAddr = \"FF02::1\"\n         self.buffer = 2048\n         \n         self.currentGameNumberOfPlayers = 0\n-        \n-        \n+    \n+    #Função que escolhe ids de músicas aleatórias da base da dados disponível   \n+    def generateOptions(self):\n+        global maxGameRounds\n+        options = []\n+        maxOptions = maxGameRounds\n\\ No newline at end of file\n+        while len(options)<maxOptions:\n+            option = str(random.randint(1,len(self.songList)))\n+            if option not in options:\n+                options.append(option)\n+        return options\n+    \n+    #\n+    \n     def generateGame(self):\n         song = str(random.randint(1,len(self.songList)))\n+        options = self.generateOptions()\n+        print(\"Músicas escolhidas:\")\n+        for option in options:\n+            print(self.songList[option][\"title\"])\n         \n-    def generateOptions(self):\n-        options = []\n-        maxOptions = \n+    \n"
                },
                {
                    "date": 1652463021989,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -164,9 +164,9 @@\n         \n         self.currentGameNumberOfPlayers = 0\n     \n     #Função que escolhe ids de músicas aleatórias da base da dados disponível   \n-    def generateOptions(self):\n+    def chooseSongs(self):\n         global maxGameRounds\n         options = []\n         maxOptions = maxGameRounds\n         while len(options)<maxOptions:\n@@ -174,14 +174,22 @@\n             if option not in options:\n                 options.append(option)\n         return options\n     \n-    #\n-    \n+    \"\"\"Funcao que escolhe para cada elemento da lista de opções de músicas, vai à base de dados e escolhe 3 outras músicas aleatórias, consistindo um grupo de escolhas nos seguinte formato:\n+        1 - <artist> - <tittle>\n+        2 - <artist> - <tittle>\n+        3 - <artist> - <tittle>\n+        4 - <artist> - <tittle>\n+    \"\"\"\n+    def generateOptions(self, options):\n+        \n\\ No newline at end of file\n+        \n+        \n     def generateGame(self):\n         song = str(random.randint(1,len(self.songList)))\n-        options = self.generateOptions()\n+        options = self.chooseOptions()\n         print(\"Músicas escolhidas:\")\n         for option in options:\n             print(self.songList[option][\"title\"])\n         \n-    \n+    \n"
                },
                {
                    "date": 1652463642464,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,5 +1,5 @@\n-import socket, threading, time, sys, pickle, random, time, sys, json\n+import socket, threading, time, sys, pickle, random, time, sys, json, Sender\n \n \n \n clients = dict()\n@@ -174,22 +174,51 @@\n             if option not in options:\n                 options.append(option)\n         return options\n     \n-    \"\"\"Funcao que escolhe para cada elemento da lista de opções de músicas, vai à base de dados e escolhe 3 outras músicas aleatórias, consistindo um grupo de escolhas nos seguinte formato:\n-        1 - <artist> - <tittle>\n-        2 - <artist> - <tittle>\n-        3 - <artist> - <tittle>\n-        4 - <artist> - <tittle>\n+    \"\"\"Funcao que escolhe para cada elemento da lista de opções de músicas, vai à base de dados e escolhe 3 outras músicas aleatórias, consistindo um dicionário de escolhas nos seguinte formato:\n+        rounds = {\n+                    \"1\": {\n+                        \"1\": \"<artist>-<song>\",   \n+                        \"2\": \"<artist>-<song>\",\n+                        \"3\": \"<artist>-<song>\",\n+                        \"4\": \"<artist>-<song>\",\n+                        },\n+                    \"2\": {\n+                        \"1\": \"<artist>-<song>\",\n+                        \"2\": \"<artist>-<song>\",\n+                        \"3\": \"<artist>-<song>\",\n+                        \"4\": \"<artist>-<song>\",\n\\ No newline at end of file\n+                        },\n+                        ...\n+                    }\n     \"\"\"\n-    def generateOptions(self, options):\n+    def generateOptions(self, options, numberOfRounds):\n+        rounds = {}\n+        for i in range(numberOfRounds):\n+            rounds[str(i+1)] = {}\n+            for j in range(4):\n+                rounds[str(i+1)][str(j+1)] = self.songList[options[i]][\"artist\"] + \"-\" + self.songList[options[i]][\"song\"]\n+                options.remove(options[i])\n+                for k in range(3):\n+                    option = str(random.randint(1,len(self.songList)))\n+                    if option not in options:\n+                        options.append(option)\n+                    rounds[str(i+1)][str(j+1+k+1)] = self.songList[option][\"artist\"] + \"-\" + self.songList[option][\"song\"]\n+        return rounds\n         \n-        \n-        \n     def generateGame(self):\n-        song = str(random.randint(1,len(self.songList)))\n         options = self.chooseOptions()\n         print(\"Músicas escolhidas:\")\n         for option in options:\n             print(self.songList[option][\"title\"])\n-        \n-    \n+        print(\"Opções de jogo:\")\n+        rounds = self.generateOptions(options, maxGameRounds)\n+        print(rounds)\n+        filePaths = []\n+        for option in options:\n+            #get all the filePaths of the songs\n+            filePaths.append(self.songList[option][\"filePath\"])\n+        print(\"Procedendo ao envio das músicas...\")\n+        for i in range(len(filePaths)):\n+            print(\"A enviar música \" + str(i+1) + \" de \" + str(len(filePaths)))\n+            sen = Sender.Sender()\n"
                },
                {
                    "date": 1652463980005,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -160,8 +160,12 @@\n         self.mCastSocket.setsockopt(socket.IPPROTO_IPV6, socket.IPV6_MULTICAST_HOPS, 100)\n         self.mcastPort = 8888\n         self.mcastAddr = \"FF02::1\"\n         self.buffer = 2048\n+        self.controlSocket = socket.socket(socket.AF_INET6, socket.SOCK_DGRAM)\n+        self.controlPort = 8081\n+        self.controlSocket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n+        self.controlSocket.bind(('', self.controlPort))\n         \n         self.currentGameNumberOfPlayers = 0\n     \n     #Função que escolhe ids de músicas aleatórias da base da dados disponível   \n@@ -206,19 +210,31 @@\n                     rounds[str(i+1)][str(j+1+k+1)] = self.songList[option][\"artist\"] + \"-\" + self.songList[option][\"song\"]\n         return rounds\n         \n     def generateGame(self):\n-        options = self.chooseOptions()\n+        global totalReadyPlayers\n+        gameSongs = self.chooseOptions()\n         print(\"Músicas escolhidas:\")\n         for option in options:\n             print(self.songList[option][\"title\"])\n         print(\"Opções de jogo:\")\n-        rounds = self.generateOptions(options, maxGameRounds)\n+        rounds = self.generateOptions(gameSongs, maxGameRounds)\n         print(rounds)\n         filePaths = []\n-        for option in options:\n+        recvCounter = 0\n+        for option in gameSongs:\n             #get all the filePaths of the songs\n\\ No newline at end of file\n             filePaths.append(self.songList[option][\"filePath\"])\n         print(\"Procedendo ao envio das músicas...\")\n         for i in range(len(filePaths)):\n             print(\"A enviar música \" + str(i+1) + \" de \" + str(len(filePaths)))\n-            sen = Sender.Sender()\n+            sen = Sender.Sender(self.mcastAddr,self.mcastPort,filePaths[i],self.mCastSocket)\n+            while recvCounter <= totalReadyPlayers:\n+                data, addr = self.socket.recvfrom(self.buffer)\n+                data = data.decode()\n+                if data.split('-')[0] == \"songReceiveOk\":\n+                    recvCounter+=1\n+                    print(\"Música \" + str(i+1) + \" enviada e confirmada\")\n+        print(\"Músicas enviadas\")\n+        for i in range(totalReadyPlayers):\n+            print(\"A enviar opções de jogo...\")\n+            \n"
                },
                {
                    "date": 1652464001529,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -233,8 +233,10 @@\n                 data = data.decode()\n                 if data.split('-')[0] == \"songReceiveOk\":\n                     recvCounter+=1\n                     print(\"Música \" + str(i+1) + \" enviada e confirmada\")\n+            recvCounter = 0\n         print(\"Músicas enviadas\")\n         for i in range(totalReadyPlayers):\n             print(\"A enviar opções de jogo...\")\n\\ No newline at end of file\n-            \n+            sen = Sender.Sender(self.mcastAddr,self.mcastPort,json.dumps(rounds),self.mCastSocket)\n+            while \n"
                },
                {
                    "date": 1652464094727,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -228,15 +228,21 @@\n         for i in range(len(filePaths)):\n             print(\"A enviar música \" + str(i+1) + \" de \" + str(len(filePaths)))\n             sen = Sender.Sender(self.mcastAddr,self.mcastPort,filePaths[i],self.mCastSocket)\n             while recvCounter <= totalReadyPlayers:\n-                data, addr = self.socket.recvfrom(self.buffer)\n+                data, addr = self.controlSocket.recvfrom(self.buffer)\n                 data = data.decode()\n                 if data.split('-')[0] == \"songReceiveOk\":\n                     recvCounter+=1\n                     print(\"Música \" + str(i+1) + \" enviada e confirmada\")\n             recvCounter = 0\n         print(\"Músicas enviadas\")\n-        for i in range(totalReadyPlayers):\n-            print(\"A enviar opções de jogo...\")\n-            sen = Sender.Sender(self.mcastAddr,self.mcastPort,json.dumps(rounds),self.mCastSocket)\n\\ No newline at end of file\n-            while \n+        print(\"A enviar opções de jogo...\")\n+        sen = Sender.Sender(self.mcastAddr,self.mcastPort,json.dumps(rounds),self.mCastSocket)\n+        while recvCounter <= totalReadyPlayers:\n+            data, addr = self.controlSocket.recvfrom(self.buffer)\n+            data = data.decode()\n+            if data.split('-')[0] == \"roundsReceiveOk\":\n+                recvCounter+=1\n+                print(\"Opções de jogo enviadas e confirmadas\")\n+        recvCounter = 0\n+        print(\"Opções de jogo enviadas\")\n"
                },
                {
                    "date": 1652465672212,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -245,4 +245,23 @@\n                 recvCounter+=1\n                 print(\"Opções de jogo enviadas e confirmadas\")\n         recvCounter = 0\n         print(\"Opções de jogo enviadas\")\n+        print(\"A iniciar o jogo...\")\n+        self.currentGameNumberOfPlayers = totalReadyPlayers\n+        self.mCastSocket.sendto(\"gameStart\".encode(),(self.mcastAddr,self.mcastPort))\n+        while recvCounter <= self.currentGameNumberOfPlayers:\n+            data, addr = self.controlSocket.recvfrom(self.buffer)\n+            data = data.decode()\n+            if data.split('-')[0] == \"gameStartOk\":\n+                recvCounter+=1\n+                print(\"Jogo iniciado\")\n+        recvCounter = 0\n+        print(\"À espera de submissão das músicas...\")\n+        playersAnswers = dict()\n+        while recvCounter <= self.currentGameNumberOfPlayers:\n+            data, addr = self.controlSocket.recvfrom(self.buffer)\n+            data = data.decode()\n+            if data.split('-')[0] == \"playerAnswer\":\n+                playersAnswers[addr[0]]=data.split('-')[1]+\"-\"+data.split('-')[2]+\"-\"+data.split('-')[3]\n+                recvCounter+=1\n+        print(\"Submissões recebidas\")\n\\ No newline at end of file\n"
                },
                {
                    "date": 1652466292815,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -208,9 +208,9 @@\n                     if option not in options:\n                         options.append(option)\n                     rounds[str(i+1)][str(j+1+k+1)] = self.songList[option][\"artist\"] + \"-\" + self.songList[option][\"song\"]\n         return rounds\n-        \n+    \n     def generateGame(self):\n         global totalReadyPlayers\n         gameSongs = self.chooseOptions()\n         print(\"Músicas escolhidas:\")\n@@ -263,5 +263,6 @@\n             data = data.decode()\n             if data.split('-')[0] == \"playerAnswer\":\n                 playersAnswers[addr[0]]=data.split('-')[1]+\"-\"+data.split('-')[2]+\"-\"+data.split('-')[3]\n                 recvCounter+=1\n-        print(\"Submissões recebidas\")\n\\ No newline at end of file\n+        print(\"Submissões recebidas\")\n+        \n\\ No newline at end of file\n"
                },
                {
                    "date": 1652466682984,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -263,6 +263,7 @@\n             data = data.decode()\n             if data.split('-')[0] == \"playerAnswer\":\n                 playersAnswers[addr[0]]=data.split('-')[1]+\"-\"+data.split('-')[2]+\"-\"+data.split('-')[3]\n                 recvCounter+=1\n-        print(\"Submissões recebidas\")\n+        print(\"Submissões recebidas:\")\n+        print(playersAnswers)\n         \n\\ No newline at end of file\n"
                },
                {
                    "date": 1652466696900,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -261,9 +261,9 @@\n         while recvCounter <= self.currentGameNumberOfPlayers:\n             data, addr = self.controlSocket.recvfrom(self.buffer)\n             data = data.decode()\n             if data.split('-')[0] == \"playerAnswer\":\n-                playersAnswers[addr[0]]=data.split('-')[1]+\"-\"+data.split('-')[2]+\"-\"+data.split('-')[3]\n+                playersAnswers[addr[0]]=data.split('-')[1]+\"-\"+data.split('-')[2]+\"-\"+data.split('-')[3]+\"-\"+data.split('-')[4]\n                 recvCounter+=1\n         print(\"Submissões recebidas:\")\n         print(playersAnswers)\n         \n\\ No newline at end of file\n"
                },
                {
                    "date": 1652466720310,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -257,8 +257,11 @@\n                 print(\"Jogo iniciado\")\n         recvCounter = 0\n         print(\"À espera de submissão das músicas...\")\n         playersAnswers = dict()\n+        \"\"\"\n+    \n+        \"\"\"\n         while recvCounter <= self.currentGameNumberOfPlayers:\n             data, addr = self.controlSocket.recvfrom(self.buffer)\n             data = data.decode()\n             if data.split('-')[0] == \"playerAnswer\":\n"
                },
                {
                    "date": 1652466738264,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -258,8 +258,11 @@\n         recvCounter = 0\n         print(\"À espera de submissão das músicas...\")\n         playersAnswers = dict()\n         \"\"\"\n+        playersAnswers = {\n+                        1: {\n+                            <round>: {\n     \n         \"\"\"\n         while recvCounter <= self.currentGameNumberOfPlayers:\n             data, addr = self.controlSocket.recvfrom(self.buffer)\n"
                },
                {
                    "date": 1652466745022,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -260,9 +260,9 @@\n         playersAnswers = dict()\n         \"\"\"\n         playersAnswers = {\n                         1: {\n-                            <round>: {\n+                            <round>: { \"choice\": \"\n     \n         \"\"\"\n         while recvCounter <= self.currentGameNumberOfPlayers:\n             data, addr = self.controlSocket.recvfrom(self.buffer)\n"
                },
                {
                    "date": 1652466753993,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -260,9 +260,11 @@\n         playersAnswers = dict()\n         \"\"\"\n         playersAnswers = {\n                         1: {\n-                            <round>: { \"choice\": \"\n+                            <round>: { \"choice\": \"1\", \"time\": \"0.0\" },\n+                            <round>: { \"choice\": \"1\", \"time\": \"0.0\" },\n+                            <\n     \n         \"\"\"\n         while recvCounter <= self.currentGameNumberOfPlayers:\n             data, addr = self.controlSocket.recvfrom(self.buffer)\n"
                },
                {
                    "date": 1652466762776,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -262,9 +262,10 @@\n         playersAnswers = {\n                         1: {\n                             <round>: { \"choice\": \"1\", \"time\": \"0.0\" },\n                             <round>: { \"choice\": \"1\", \"time\": \"0.0\" },\n-                            <\n+                            <round>:    ...\n+                            }\n     \n         \"\"\"\n         while recvCounter <= self.currentGameNumberOfPlayers:\n             data, addr = self.controlSocket.recvfrom(self.buffer)\n"
                },
                {
                    "date": 1652466772138,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -260,10 +260,10 @@\n         playersAnswers = dict()\n         \"\"\"\n         playersAnswers = {\n                         1: {\n+                            <round>: { \"choice\": \"0\", \"time\": \"0.0\" },\n                             <round>: { \"choice\": \"1\", \"time\": \"0.0\" },\n-                            <round>: { \"choice\": \"1\", \"time\": \"0.0\" },\n                             <round>:    ...\n                             }\n     \n         \"\"\"\n"
                },
                {
                    "date": 1652466781838,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -259,11 +259,11 @@\n         print(\"À espera de submissão das músicas...\")\n         playersAnswers = dict()\n         \"\"\"\n         playersAnswers = {\n-                        1: {\n+                        <playerId>: {\n                             <round>: { \"choice\": \"0\", \"time\": \"0.0\" },\n-                            <round>: { \"choice\": \"1\", \"time\": \"0.0\" },\n+                            <round>: { \"choice\": \"0\", \"time\": \"0.0\" },\n                             <round>:    ...\n                             }\n     \n         \"\"\"\n"
                },
                {
                    "date": 1652466837021,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -9,9 +9,8 @@\n \n class networkStatusHandler(threading.Thread):\n     def __init__(self):\n         threading.Thread.__init__(self)\n-        self.controlPort = 8080\n         self.hostName = socket.gethostname()\n         self.buffer = 2048\n         self.mcastAddr = \"FF01:0:0:0:0:0:0:1\"\n    \n"
                },
                {
                    "date": 1652466868000,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -72,9 +72,11 @@\n         while True:\n             data, addr = self.socket.recvfrom(self.buffer)\n             data = data.decode()\n             #Cases para a receção de dados:\n-            \n+            \"\"\"\n+            1\n+            \"\"\"\n             if data.split('-')[0]==\"new\":\n                 print(\"Nova conexao de \" + str(data.split('-')[1]))\n                 if self.addClient(addr,addr[1])==1:\n                     print(\"Cliente adicionado\"  + str(addr))\n"
                },
                {
                    "date": 1652466884647,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -73,9 +73,10 @@\n             data, addr = self.socket.recvfrom(self.buffer)\n             data = data.decode()\n             #Cases para a receção de dados:\n             \"\"\"\n-            1\n+            1 - Cliente envia mensagem new-addr\n+            2 - Servidor responde com hello-addr-mcastAddr\n             \"\"\"\n             if data.split('-')[0]==\"new\":\n                 print(\"Nova conexao de \" + str(data.split('-')[1]))\n                 if self.addClient(addr,addr[1])==1:\n"
                },
                {
                    "date": 1652467050010,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -75,8 +75,13 @@\n             #Cases para a receção de dados:\n             \"\"\"\n             1 - Cliente envia mensagem new-addr\n             2 - Servidor responde com hello-addr-mcastAddr\n+            3 - Cliente envia mensagem de confirmação de mcastAddr\n+            4 - Servidor envia mensagem com ready?\n+            5 - Cliente responde com readyOk\n+            7 - Servidor entra em loop de hearbeat (e cliente associado)\n+            8 - Cliente envia mensagem de disconnect opcional quando quiser.\n             \"\"\"\n             if data.split('-')[0]==\"new\":\n                 print(\"Nova conexao de \" + str(data.split('-')[1]))\n                 if self.addClient(addr,addr[1])==1:\n@@ -97,8 +102,9 @@\n                     print(\"Cliente não está autenticado... A descartar...\")\n             elif data.split('-')[0]==\"readyOk\":\n                 print(\"cliente \" + str(addr[0]) + \" está pronto\")\n                 print(\"Estado actualizado dos clientes\")\n+                self.setClientReady(addr[0])\n             \n             elif data.split('-')[0]==\"disconnect\":\n                 print(\"A remover cliente \" + str(addr[0]))\n                 self.removeClient(addr[0])\n"
                },
                {
                    "date": 1652467279355,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -6,8 +6,25 @@\n maxPlayersForGame = 2\n totalReadyPlayers = 0\n maxGameRounds = 3\n \n+\"\"\" \n+clients : {\n+    <client_id> : {\n+        port : <port>,\n+        ready : <bool>,\n+        ingame : <bool>,\n+        online : <bool>,\n+    },\n+    <client_id> : {\n+        port : <port>,\n+        ready : <bool>,\n+        ingame : <bool>,\n+        online : <bool>,\n+    },\n+    ....\n+\"\"\"\n+\n class networkStatusHandler(threading.Thread):\n     def __init__(self):\n         threading.Thread.__init__(self)\n         self.hostName = socket.gethostname()\n@@ -221,9 +238,9 @@\n     def generateGame(self):\n         global totalReadyPlayers\n         gameSongs = self.chooseOptions()\n         print(\"Músicas escolhidas:\")\n-        for option in options:\n+        for option in gameOptions:\n             print(self.songList[option][\"title\"])\n         print(\"Opções de jogo:\")\n         rounds = self.generateOptions(gameSongs, maxGameRounds)\n         print(rounds)\n"
                },
                {
                    "date": 1652468547819,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -238,9 +238,9 @@\n     def generateGame(self):\n         global totalReadyPlayers\n         gameSongs = self.chooseOptions()\n         print(\"Músicas escolhidas:\")\n-        for option in gameOptions:\n+        for option in gameSongs:\n             print(self.songList[option][\"title\"])\n         print(\"Opções de jogo:\")\n         rounds = self.generateOptions(gameSongs, maxGameRounds)\n         print(rounds)\n@@ -289,15 +289,9 @@\n                             <round>: { \"choice\": \"0\", \"time\": \"0.0\" },\n                             <round>: { \"choice\": \"0\", \"time\": \"0.0\" },\n                             <round>:    ...\n                             }\n+        respostaplayer : <escolha>-<tempo>-<escolha>-<tempo>-<escolha>-<tempo> (nrounds)\n+        \"\"\"\n     \n-        \"\"\"\n-        while recvCounter <= self.currentGameNumberOfPlayers:\n-            data, addr = self.controlSocket.recvfrom(self.buffer)\n-            data = data.decode()\n-            if data.split('-')[0] == \"playerAnswer\":\n-                playersAnswers[addr[0]]=data.split('-')[1]+\"-\"+data.split('-')[2]+\"-\"+data.split('-')[3]+\"-\"+data.split('-')[4]\n-                recvCounter+=1\n-        print(\"Submissões recebidas:\")\n-        print(playersAnswers)\n+        \n         \n\\ No newline at end of file\n"
                },
                {
                    "date": 1652543887883,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -189,9 +189,9 @@\n         self.controlSocket = socket.socket(socket.AF_INET6, socket.SOCK_DGRAM)\n         self.controlPort = 8081\n         self.controlSocket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n         self.controlSocket.bind(('', self.controlPort))\n-        \n+        self.currentGamePlayers = dict()\n         self.currentGameNumberOfPlayers = 0\n     \n     #Função que escolhe ids de músicas aleatórias da base da dados disponível   \n     def chooseSongs(self):\n@@ -201,12 +201,13 @@\n         while len(options)<maxOptions:\n             option = str(random.randint(1,len(self.songList)))\n             if option not in options:\n                 options.append(option)\n-        return options\n+        return options    \n     \n-    \"\"\"Funcao que escolhe para cada elemento da lista de opções de músicas, vai à base de dados e escolhe 3 outras músicas aleatórias, consistindo um dicionário de escolhas nos seguinte formato:\n-        rounds = {\n+    \"\"\"Função que recebe a lista de músicas escolhidas para o jogo (options),  vai buscar outras 3 opções para cada musica escolhida e coloca num dicionário no seguinte formato:\n+    \n+             = {\n                     \"1\": {\n                         \"1\": \"<artist>-<song>\",   \n                         \"2\": \"<artist>-<song>\",\n                         \"3\": \"<artist>-<song>\",\n@@ -219,79 +220,18 @@\n                         \"4\": \"<artist>-<song>\",\n                         },\n                         ...\n                     }\n+            O número de opções é sempre 4, e o número de rondas é igual ao maxGameRounds passado como argumento.\n     \"\"\"\n-    def generateOptions(self, options, numberOfRounds):\n-        rounds = {}\n-        for i in range(numberOfRounds):\n-            rounds[str(i+1)] = {}\n-            for j in range(4):\n-                rounds[str(i+1)][str(j+1)] = self.songList[options[i]][\"artist\"] + \"-\" + self.songList[options[i]][\"song\"]\n-                options.remove(options[i])\n-                for k in range(3):\n-                    option = str(random.randint(1,len(self.songList)))\n-                    if option not in options:\n-                        options.append(option)\n-                    rounds[str(i+1)][str(j+1+k+1)] = self.songList[option][\"artist\"] + \"-\" + self.songList[option][\"song\"]\n-        return rounds\n-    \n+    def getOptions(self,options,maxGameRounds):\n+        optionsDict = {}\n+        for i in range(0,len(options)):\n+            optionsDict[str(i+1)] = {}\n+            for j in range(1,5):\n+                optionsDict[str(i+1)][str(j)] = self.songList[options[i]][\"artist\"] + \"-\" + self.songList[options[i]][\"song\"]\n+        return optionsDict\n+        \n     def generateGame(self):\n         global totalReadyPlayers\n-        gameSongs = self.chooseOptions()\n-        print(\"Músicas escolhidas:\")\n-        for option in gameSongs:\n-            print(self.songList[option][\"title\"])\n-        print(\"Opções de jogo:\")\n-        rounds = self.generateOptions(gameSongs, maxGameRounds)\n-        print(rounds)\n-        filePaths = []\n-        recvCounter = 0\n-        for option in gameSongs:\n-            #get all the filePaths of the songs\n-            filePaths.append(self.songList[option][\"filePath\"])\n-        print(\"Procedendo ao envio das músicas...\")\n-        for i in range(len(filePaths)):\n-            print(\"A enviar música \" + str(i+1) + \" de \" + str(len(filePaths)))\n-            sen = Sender.Sender(self.mcastAddr,self.mcastPort,filePaths[i],self.mCastSocket)\n-            while recvCounter <= totalReadyPlayers:\n-                data, addr = self.controlSocket.recvfrom(self.buffer)\n-                data = data.decode()\n-                if data.split('-')[0] == \"songReceiveOk\":\n-                    recvCounter+=1\n-                    print(\"Música \" + str(i+1) + \" enviada e confirmada\")\n-            recvCounter = 0\n-        print(\"Músicas enviadas\")\n-        print(\"A enviar opções de jogo...\")\n-        sen = Sender.Sender(self.mcastAddr,self.mcastPort,json.dumps(rounds),self.mCastSocket)\n-        while recvCounter <= totalReadyPlayers:\n-            data, addr = self.controlSocket.recvfrom(self.buffer)\n-            data = data.decode()\n-            if data.split('-')[0] == \"roundsReceiveOk\":\n-                recvCounter+=1\n-                print(\"Opções de jogo enviadas e confirmadas\")\n-        recvCounter = 0\n-        print(\"Opções de jogo enviadas\")\n-        print(\"A iniciar o jogo...\")\n-        self.currentGameNumberOfPlayers = totalReadyPlayers\n-        self.mCastSocket.sendto(\"gameStart\".encode(),(self.mcastAddr,self.mcastPort))\n-        while recvCounter <= self.currentGameNumberOfPlayers:\n-            data, addr = self.controlSocket.recvfrom(self.buffer)\n-            data = data.decode()\n-            if data.split('-')[0] == \"gameStartOk\":\n-                recvCounter+=1\n-                print(\"Jogo iniciado\")\n-        recvCounter = 0\n-        print(\"À espera de submissão das músicas...\")\n-        playersAnswers = dict()\n-        \"\"\"\n-        playersAnswers = {\n-                        <playerId>: {\n-                            <round>: { \"choice\": \"0\", \"time\": \"0.0\" },\n-                            <round>: { \"choice\": \"0\", \"time\": \"0.0\" },\n-                            <round>:    ...\n-                            }\n-        respostaplayer : <escolha>-<tempo>-<escolha>-<tempo>-<escolha>-<tempo> (nrounds)\n-        \"\"\"\n-    \n         \n         \n\\ No newline at end of file\n"
                },
                {
                    "date": 1652543955778,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -229,9 +229,11 @@\n             optionsDict[str(i+1)] = {}\n             for j in range(1,5):\n                 optionsDict[str(i+1)][str(j)] = self.songList[options[i]][\"artist\"] + \"-\" + self.songList[options[i]][\"song\"]\n         return optionsDict\n-        \n+     \n+    #Função respnsável por popular o dicionário de currentGamePlayers com os ids dos clientes com estado ready até um máximo de totalReadyPlayers\n+       \n     def generateGame(self):\n         global totalReadyPlayers\n         \n         \n\\ No newline at end of file\n"
                },
                {
                    "date": 1652544405764,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -189,9 +189,9 @@\n         self.controlSocket = socket.socket(socket.AF_INET6, socket.SOCK_DGRAM)\n         self.controlPort = 8081\n         self.controlSocket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n         self.controlSocket.bind(('', self.controlPort))\n-        self.currentGamePlayers = dict()\n+        self.currentGamePlayers = []\n         self.currentGameNumberOfPlayers = 0\n     \n     #Função que escolhe ids de músicas aleatórias da base da dados disponível   \n     def chooseSongs(self):\n@@ -231,9 +231,28 @@\n                 optionsDict[str(i+1)][str(j)] = self.songList[options[i]][\"artist\"] + \"-\" + self.songList[options[i]][\"song\"]\n         return optionsDict\n      \n     #Função respnsável por popular o dicionário de currentGamePlayers com os ids dos clientes com estado ready até um máximo de totalReadyPlayers\n+    def getReadyPlayers(self,totalReadyPlayers):\n+        global clients\n+        readyPlayers = []\n+        for addr in clients.keys():\n+            if clients[addr][\"ready\"]==1:\n+                readyPlayers.append(addr)\n+        if len(readyPlayers)<totalReadyPlayers:\n+            print(\"Número de jogadores insuficiente para iniciar o jogo\")\n+            return False\n+        else:\n+            return readyPlayers\n        \n     def generateGame(self):\n         global totalReadyPlayers\n-        \n+        self.getReadyPlayers()\n+        self.currentGamePlayers = self.getReadyPlayers(totalReadyPlayers)\n+        #Escolher <maxGameRounds> músicas aleatórias da base de dados para o jogo\n+        selectedSongs = self.chooseSongs()\n+        gameOptions = self.getOptions(selectedSongs,maxGameRounds)\n+        #Enviar os ficheiros de cada música para os clientes via multicast, instanciando a classe Sender para tal, e passando os parâmetros necessários\n+        #Necessário esperar a confirmacao dos clientes através do control socket\n+        for i in range(0,len(selectedSongs)):\n+            \n         \n\\ No newline at end of file\n"
                },
                {
                    "date": 1652545055502,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -250,9 +250,27 @@\n         self.currentGamePlayers = self.getReadyPlayers(totalReadyPlayers)\n         #Escolher <maxGameRounds> músicas aleatórias da base de dados para o jogo\n         selectedSongs = self.chooseSongs()\n         gameOptions = self.getOptions(selectedSongs,maxGameRounds)\n-        #Enviar os ficheiros de cada música para os clientes via multicast, instanciando a classe Sender para tal, e passando os parâmetros necessários\n-        #Necessário esperar a confirmacao dos clientes através do control socket\n-        for i in range(0,len(selectedSongs)):\n-            \n-        \n\\ No newline at end of file\n+        controlCounter = 0\n+        filepaths = []\n+        filepaths = [self.songList[song][\"filepath\"] for song in selectedSongs]\n+        \n+        for i in range(0,len(filepaths)):\n+            sen = Sender.Sender(self.mcastAddr,self.mcastPort,filepaths[i],self.mCastSocket)\n+            sen.start()\n+        while controlCounter < len(self.currentGamePlayers):\n+            data, addr = self.controlSocket.recvfrom(self.buffer)\n+            if data.decode()==\"fileOk\":\n+                print(\"Jogador \" + str(addr) + \" confirma recepção\")\n+                controlcounter += 1\n+        print(\"Músicas enviadas para os jogadores\")\n+        controlCounter = 0\n+        sen = Sender.Sender(self.mcastAddr,self.mCastPort,pickle.dumps(gameOptions),self.mCastSocket)\n+        while controlCounter <= maxGameRounds:\n+            data,addr = self.controlSocket.recvfrom(self.buffer)\n+            if data.decode()==\"roundOk\":\n+                print(\"Jogador \" + str(addr) + \" confirma recepção\")\n+                controlCounter += 1\n+        print(\"Opções enviadas para os jogadores\")\n+        \n+        \n"
                },
                {
                    "date": 1652545826586,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -242,9 +242,21 @@\n             print(\"Número de jogadores insuficiente para iniciar o jogo\")\n             return False\n         else:\n             return readyPlayers\n+    \n+    def multiCastCommunicationLoop(self,filePath):\n+        sen = Sender.Sender(self.mcastAddr,self.mcastPort,filePath,self.mCastSocket)\n+        sen.start()\n        \n+    def controlMCast(self,controlString):\n+        controlCounter = 0\n+        while controlCounter < len(self.currentGamePlayers)\n+            data, addr = self.controlSocket.recvfrom(self.buffer)\n+            if data.decode() == controlString:\n+                print(\"Jogador \" + str(addr) + \" confirmou a recepção do ficheiro\")\n+                controlCounter += 1\n+    \n     def generateGame(self):\n         global totalReadyPlayers\n         self.getReadyPlayers()\n         self.currentGamePlayers = self.getReadyPlayers(totalReadyPlayers)\n@@ -255,10 +267,9 @@\n         filepaths = []\n         filepaths = [self.songList[song][\"filepath\"] for song in selectedSongs]\n         \n         for i in range(0,len(filepaths)):\n-            sen = Sender.Sender(self.mcastAddr,self.mcastPort,filepaths[i],self.mCastSocket)\n-            sen.start()\n+            multicast\n         while controlCounter < len(self.currentGamePlayers):\n             data, addr = self.controlSocket.recvfrom(self.buffer)\n             if data.decode()==\"fileOk\":\n                 print(\"Jogador \" + str(addr) + \" confirma recepção\")\n@@ -271,6 +282,8 @@\n             if data.decode()==\"roundOk\":\n                 print(\"Jogador \" + str(addr) + \" confirma recepção\")\n                 controlCounter += 1\n         print(\"Opções enviadas para os jogadores\")\n+        #Enviar mensagem de começo de jogo para todos os jogadores\n         \n         \n+        \n"
                },
                {
                    "date": 1652545893541,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -254,8 +254,9 @@\n             data, addr = self.controlSocket.recvfrom(self.buffer)\n             if data.decode() == controlString:\n                 print(\"Jogador \" + str(addr) + \" confirmou a recepção do ficheiro\")\n                 controlCounter += 1\n+        print(\"Todos os jogadores acusam rececao do ficheiro\")\n     \n     def generateGame(self):\n         global totalReadyPlayers\n         self.getReadyPlayers()\n@@ -267,14 +268,12 @@\n         filepaths = []\n         filepaths = [self.songList[song][\"filepath\"] for song in selectedSongs]\n         \n         for i in range(0,len(filepaths)):\n-            multicast\n-        while controlCounter < len(self.currentGamePlayers):\n-            data, addr = self.controlSocket.recvfrom(self.buffer)\n-            if data.decode()==\"fileOk\":\n-                print(\"Jogador \" + str(addr) + \" confirma recepção\")\n-                controlcounter += 1\n+            self.multiCastCommunicationLoop(filepaths[i])\n+        self.controlMCast(\"songOk\")\n+            \n+        \n         print(\"Músicas enviadas para os jogadores\")\n         controlCounter = 0\n         sen = Sender.Sender(self.mcastAddr,self.mCastPort,pickle.dumps(gameOptions),self.mCastSocket)\n         while controlCounter <= maxGameRounds:\n"
                },
                {
                    "date": 1652545972696,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -270,13 +270,12 @@\n         \n         for i in range(0,len(filepaths)):\n             self.multiCastCommunicationLoop(filepaths[i])\n         self.controlMCast(\"songOk\")\n-            \n-        \n-        print(\"Músicas enviadas para os jogadores\")\n-        controlCounter = 0\n-        sen = Sender.Sender(self.mcastAddr,self.mCastPort,pickle.dumps(gameOptions),self.mCastSocket)\n+        print(\"Musicas enviadas\")\n+        self.multiCastCommunicationLoop(json.dumps(gameOptions))\n+        self.controlMCast(\"optionsOk\")\n+        print(\"Opções Enviadas\")\n         while controlCounter <= maxGameRounds:\n             data,addr = self.controlSocket.recvfrom(self.buffer)\n             if data.decode()==\"roundOk\":\n                 print(\"Jogador \" + str(addr) + \" confirma recepção\")\n"
                },
                {
                    "date": 1652546580817,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -243,10 +243,10 @@\n             return False\n         else:\n             return readyPlayers\n     \n-    def multiCastCommunicationLoop(self,filePath):\n-        sen = Sender.Sender(self.mcastAddr,self.mcastPort,filePath,self.mCastSocket)\n+    def multiCastCommunicationLoop(self,filePath,flag):\n+        sen = Sender.Sender(self.mcastAddr,self.mcastPort,filePath,flag,self.mCastSocket)\n         sen.start()\n        \n     def controlMCast(self,controlString):\n         controlCounter = 0\n@@ -274,14 +274,8 @@\n         print(\"Musicas enviadas\")\n         self.multiCastCommunicationLoop(json.dumps(gameOptions))\n         self.controlMCast(\"optionsOk\")\n         print(\"Opções Enviadas\")\n-        while controlCounter <= maxGameRounds:\n-            data,addr = self.controlSocket.recvfrom(self.buffer)\n-            if data.decode()==\"roundOk\":\n-                print(\"Jogador \" + str(addr) + \" confirma recepção\")\n-                controlCounter += 1\n-        print(\"Opções enviadas para os jogadores\")\n         #Enviar mensagem de começo de jogo para todos os jogadores\n+        self.controlMCast(\"startGame\")\n         \n         \n-        \n"
                },
                {
                    "date": 1652546587858,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -243,10 +243,10 @@\n             return False\n         else:\n             return readyPlayers\n     \n-    def multiCastCommunicationLoop(self,filePath,flag):\n-        sen = Sender.Sender(self.mcastAddr,self.mcastPort,filePath,flag,self.mCastSocket)\n+    def multiCastCommunicationLoop(self,file,flag):\n+        sen = Sender.Sender(self.mcastAddr,self.mcastPort,file,flag,self.mCastSocket)\n         sen.start()\n        \n     def controlMCast(self,controlString):\n         controlCounter = 0\n"
                },
                {
                    "date": 1652546614296,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -243,9 +243,9 @@\n             return False\n         else:\n             return readyPlayers\n     \n-    def multiCastCommunicationLoop(self,file,flag):\n+    def multiSender(self,file,flag):\n         sen = Sender.Sender(self.mcastAddr,self.mcastPort,file,flag,self.mCastSocket)\n         sen.start()\n        \n     def controlMCast(self,controlString):\n@@ -268,9 +268,9 @@\n         filepaths = []\n         filepaths = [self.songList[song][\"filepath\"] for song in selectedSongs]\n         \n         for i in range(0,len(filepaths)):\n-            self.multiCastCommunicationLoop(filepaths[i])\n+            self.multiSender(filepaths[i])\n         self.controlMCast(\"songOk\")\n         print(\"Musicas enviadas\")\n         self.multiCastCommunicationLoop(json.dumps(gameOptions))\n         self.controlMCast(\"optionsOk\")\n"
                },
                {
                    "date": 1652546626231,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -268,9 +268,9 @@\n         filepaths = []\n         filepaths = [self.songList[song][\"filepath\"] for song in selectedSongs]\n         \n         for i in range(0,len(filepaths)):\n-            self.multiSender(filepaths[i])\n+            self.multiSender(filepaths[i],0)\n         self.controlMCast(\"songOk\")\n         print(\"Musicas enviadas\")\n         self.multiCastCommunicationLoop(json.dumps(gameOptions))\n         self.controlMCast(\"optionsOk\")\n"
                },
                {
                    "date": 1652546873169,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -256,8 +256,18 @@\n                 print(\"Jogador \" + str(addr) + \" confirmou a recepção do ficheiro\")\n                 controlCounter += 1\n         print(\"Todos os jogadores acusam rececao do ficheiro\")\n     \n+    #Funcao responsável por iniciar um loop de recolha de respostas de jogadores através do controlSocket    \n+    def getPlayersChoices(self):\n+        controlCounter = 0\n+        while controlCounter <= len(self.currentGamePlayers):\n+            data, addr = self.controlSocket.recvfrom(self.buffer)\n+            data = data.decode()\n+            print(\"Escolhdas do jogador %s: %s recebidas\" % (str(addr),data))\n+            \n+            controlCounter += 1\n+    \n     def generateGame(self):\n         global totalReadyPlayers\n         self.getReadyPlayers()\n         self.currentGamePlayers = self.getReadyPlayers(totalReadyPlayers)\n@@ -271,11 +281,15 @@\n         for i in range(0,len(filepaths)):\n             self.multiSender(filepaths[i],0)\n         self.controlMCast(\"songOk\")\n         print(\"Musicas enviadas\")\n-        self.multiCastCommunicationLoop(json.dumps(gameOptions))\n+        self.multiSender(gameOptions,1)\n         self.controlMCast(\"optionsOk\")\n         print(\"Opções Enviadas\")\n         #Enviar mensagem de começo de jogo para todos os jogadores\n-        self.controlMCast(\"startGame\")\n+        self.controlMCast(\"startGame\",2)\n+        self.controlMCast(\"gameStartOk\")\n         \n-        \n+    def run(self):\n+        self.generateGame()\n+        controlCoun\n+        while \n"
                },
                {
                    "date": 1652546892539,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -262,10 +262,9 @@\n         controlCounter = 0\n         while controlCounter <= len(self.currentGamePlayers):\n             data, addr = self.controlSocket.recvfrom(self.buffer)\n             data = data.decode()\n-            print(\"Escolhdas do jogador %s: %s recebidas\" % (str(addr),data))\n-            \n+            print(\"Escolhdas do jogador %s: %s recebidas\" % (str(addr[0]),str(addr[1]),data))\n             controlCounter += 1\n     \n     def generateGame(self):\n         global totalReadyPlayers\n"
                },
                {
                    "date": 1652547644991,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -256,16 +256,45 @@\n                 print(\"Jogador \" + str(addr) + \" confirmou a recepção do ficheiro\")\n                 controlCounter += 1\n         print(\"Todos os jogadores acusam rececao do ficheiro\")\n     \n-    #Funcao responsável por iniciar um loop de recolha de respostas de jogadores através do controlSocket    \n-    def getPlayersChoices(self):\n+    \"\"\"\n+    Funcao responsável por iniciar um loop de recolha de respostas de jogadores através do controlSocket\n+    \n+    No final deverá ser preenchido um dicionario com o seguinte formato:\n+\n+        respostas = {\n+                        \"<player>\":{ <ronda>: <opcao>-<tempo>,\n+                                     <ronda>: <opcao>-<tempo>,\n+                                     ....\n+                                     \n+                        }\n+        }\n+    \n+    formatoDeEntrada:\n+        answers$<opcao>$tempo>$<opcao>$<tempo>$<opcao>$<tempo>\n+    \"\"\"\n+        \n+    def getPlayersChoices(self,rounds):\n+        playersAnswers = {}\n         controlCounter = 0\n         while controlCounter <= len(self.currentGamePlayers):\n             data, addr = self.controlSocket.recvfrom(self.buffer)\n             data = data.decode()\n-            print(\"Escolhdas do jogador %s: %s recebidas\" % (str(addr[0]),str(addr[1]),data))\n+            print(\"Escolhdas do jogador %s: %s recebidas\" % (str(addr[0]),str(addr[1])))\n             controlCounter += 1\n+            if addr[0] not in playersAnswers.keys():\n+                playersAnswers[addr[0]] = {}\n+                controlRoundsCounter = 0\n+                splitsCounter = 1\n+                while controlRoundsCounter < rounds:\n+                    playersAnswers[addr[0]][controlRoundsCounter][data.split('$')[splitsCounter]] = data.split('$')[splitsCounter+1]\n+                    splitsCounter += 2\n+                    controlRoundsCounter += 1\n+                return playersAnswers\n+            else:\n+                print(\"erro nas opções\")\n+                return None\n     \n     def generateGame(self):\n         global totalReadyPlayers\n         self.getReadyPlayers()\n"
                },
                {
                    "date": 1652548511539,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -294,8 +294,39 @@\n             else:\n                 print(\"erro nas opções\")\n                 return None\n     \n+    \n+    #funcao que recebe uma lista de ids de musicas e vai a songlist procurar o titlo e adicionalo ao array songstittle\n+    \n+    def getSongsTittle(self,list):\n+        songsTittle = []\n+        for i in list:\n+            songsTittle.append(self.songList[i][\"song\"])\n+        return songsTittle\n+    \"\"\"\n+    \n+    Função de calculo de vençedor\n+    Recebe as opções e as solucoes.\n+    Vai a cada entrada no dicionario:\n+          respostas = {\n+                        \"<player>\":{ <ronda>: <opcao>-<tempo>,\n+                                     <ronda>: <opcao>-<tempo>,\n+                                     ....\n+                        }\n+        }\n+    \"\"\"\n+    \n+    def findWinner(self,answers,solutions):\n+        winners = []\n+        for player in answers.keys():\n+            for round in answers[player].keys():\n+                if answers[player][round] == solutions[round]:\n+                    winners.append(player)\n+        return winners\n+        \n+    \n+    \n     def generateGame(self):\n         global totalReadyPlayers\n         self.getReadyPlayers()\n         self.currentGamePlayers = self.getReadyPlayers(totalReadyPlayers)\n@@ -315,8 +346,13 @@\n         print(\"Opções Enviadas\")\n         #Enviar mensagem de começo de jogo para todos os jogadores\n         self.controlMCast(\"startGame\",2)\n         self.controlMCast(\"gameStartOk\")\n+        answers = self.getPlayersChoices()\n+        print(\"Escolhas recebidas:\")\n+        print(answers)\n+        print(\"A determinar vencedor\")\n+        songsTittle = self.getSongsTittle()\n         \n     def run(self):\n         self.generateGame()\n         controlCoun\n"
                },
                {
                    "date": 1652548517723,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -350,9 +350,9 @@\n         answers = self.getPlayersChoices()\n         print(\"Escolhas recebidas:\")\n         print(answers)\n         print(\"A determinar vencedor\")\n-        songsTittle = self.getSongsTittle()\n+        songsTittle = self.getSongsTittle(selectedSongs)\n         \n     def run(self):\n         self.generateGame()\n         controlCoun\n"
                },
                {
                    "date": 1652549123488,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -317,12 +317,22 @@\n     \"\"\"\n     \n     def findWinner(self,answers,solutions):\n         winners = []\n+        currentGamePlayers = []\n         for player in answers.keys():\n+            currentGamePlayers.append(player)\n             for round in answers[player].keys():\n-                if answers[player][round] == solutions[round]:\n-                    winners.append(player)\n+                if answers[player][round] == solutions[round-1]:\n+                    timeSelected = answers[player][round].split('-')[1]\n+                    temp = player\n+                    for i in range(0,len(winners)):\n+                        if not winners[i] or winners[i].split('-')[1]>=timeSelected:\n+                            winners.append(player+\"-\"+timeSelected)\n+            \n+        for winner in winners:\n+            print(\"O vencedor da ronda \" + str(round) + \" é o jogador \" + winner.split('-')[0])\n+            \n         return winners\n         \n     \n     \n"
                },
                {
                    "date": 1652549265237,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -327,11 +327,14 @@\n                     temp = player\n                     for i in range(0,len(winners)):\n                         if not winners[i] or winners[i].split('-')[1]>=timeSelected:\n                             winners.append(player+\"-\"+timeSelected)\n-            \n+        results = {}\n+        for p in currentGamePlayers:\n+            results[p]=0    \n         for winner in winners:\n             print(\"O vencedor da ronda \" + str(round) + \" é o jogador \" + winner.split('-')[0])\n+            results[p]=results[p] + 1\n             \n         return winners\n         \n     \n"
                },
                {
                    "date": 1652549400690,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -332,12 +332,16 @@\n         for p in currentGamePlayers:\n             results[p]=0    \n         for winner in winners:\n             print(\"O vencedor da ronda \" + str(round) + \" é o jogador \" + winner.split('-')[0])\n-            results[p]=results[p] + 1\n-            \n-        return winners\n+            results[p]=results[p]+1\n+        print(results)\n         \n+        #get the winner from results dictionary, which is the key with the highest value\n+        winner = max(results, key=results.get)\n+        print(\"O vencedor do jogo é o jogador \" + winner)\n+        return winner\n+        \n     \n     \n     def generateGame(self):\n         global totalReadyPlayers\n"
                },
                {
                    "date": 1652549473372,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -361,16 +361,20 @@\n         self.multiSender(gameOptions,1)\n         self.controlMCast(\"optionsOk\")\n         print(\"Opções Enviadas\")\n         #Enviar mensagem de começo de jogo para todos os jogadores\n-        self.controlMCast(\"startGame\",2)\n+        self.multiSender(\"startGame\",2)\n         self.controlMCast(\"gameStartOk\")\n         answers = self.getPlayersChoices()\n         print(\"Escolhas recebidas:\")\n         print(answers)\n         print(\"A determinar vencedor\")\n         songsTittle = self.getSongsTittle(selectedSongs)\n+        winner = self.findWinner(answers,songsTittle)\n+        self.controlMCast\n         \n+        \n+        \n     def run(self):\n         self.generateGame()\n         controlCoun\n         while \n"
                },
                {
                    "date": 1652549550271,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -369,9 +369,17 @@\n         print(answers)\n         print(\"A determinar vencedor\")\n         songsTittle = self.getSongsTittle(selectedSongs)\n         winner = self.findWinner(answers,songsTittle)\n-        self.controlMCast\n+        self.controlMCast(\"O vencedor é o jogador \" + winner)\n+        self.controlMCast(\"okEndgame\")\n+        self.totalReadyPlayers = 0\n+        #set all players from this game to not ready\n+        for player in self.currentGamePlayers:\n+            self.players[player][\"ready\"] = False\n+        self.currentGamePlayers = []\n+        self.gameCounter += 1\n+    \n         \n         \n         \n     def run(self):\n"
                },
                {
                    "date": 1652549643951,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -374,11 +374,11 @@\n         self.controlMCast(\"okEndgame\")\n         self.totalReadyPlayers = 0\n         #set all players from this game to not ready\n         for player in self.currentGamePlayers:\n-            self.players[player][\"ready\"] = False\n+            for player in clients:\n+                self.clients[player][\"ready\"] = False\n         self.currentGamePlayers = []\n-        self.gameCounter += 1\n     \n         \n         \n         \n"
                },
                {
                    "date": 1652549652438,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -377,12 +377,12 @@\n         for player in self.currentGamePlayers:\n             for player in clients:\n                 self.clients[player][\"ready\"] = False\n         self.currentGamePlayers = []\n-    \n         \n         \n         \n+        \n     def run(self):\n         self.generateGame()\n         controlCoun\n         while \n"
                },
                {
                    "date": 1652549694542,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -249,9 +249,9 @@\n         sen.start()\n        \n     def controlMCast(self,controlString):\n         controlCounter = 0\n-        while controlCounter < len(self.currentGamePlayers)\n+        while controlCounter < len(self.currentGamePlayers):\n             data, addr = self.controlSocket.recvfrom(self.buffer)\n             if data.decode() == controlString:\n                 print(\"Jogador \" + str(addr) + \" confirmou a recepção do ficheiro\")\n                 controlCounter += 1\n@@ -344,8 +344,9 @@\n     \n     \n     def generateGame(self):\n         global totalReadyPlayers\n+        global clients\n         self.getReadyPlayers()\n         self.currentGamePlayers = self.getReadyPlayers(totalReadyPlayers)\n         #Escolher <maxGameRounds> músicas aleatórias da base de dados para o jogo\n         selectedSongs = self.chooseSongs()\n@@ -377,12 +378,6 @@\n         for player in self.currentGamePlayers:\n             for player in clients:\n                 self.clients[player][\"ready\"] = False\n         self.currentGamePlayers = []\n-        \n-        \n-        \n-        \n     def run(self):\n         self.generateGame()\n-        controlCoun\n-        while \n"
                },
                {
                    "date": 1652549834958,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -380,4 +380,18 @@\n                 self.clients[player][\"ready\"] = False\n         self.currentGamePlayers = []\n     def run(self):\n         self.generateGame()\n+\n+\n+def main():\n+    #Inicializar as threads networkStatusHandler, heartbeatHandler e Game\n+    networkStatusHandler = networkStatusHandler()\n+    heartbeatHandler = heartbeatHandler()\n+    gameHandler = Game()\n+    networkStatusHandler.start()\n+    heartbeatHandler.start()\n+    gameHandler.start()\n+    \n+\n+if __name__ == \"__main__\":\n+    main()\n\\ No newline at end of file\n"
                },
                {
                    "date": 1652552383752,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -107,9 +107,9 @@\n                     print(clients)\n                     print(\"A enviar confirmação para os clientes:\")\n                     self.socket.sendto(bytes((\"hello-%s-%s\"),addr[0],self.mcastAddr),addr)\n                     print(\"Endereço Multicast Enviado\")\n-            elif data.split('-')[0]==\"mcast-ok\":\n+            elif data.split('-')[0]==\"mcast\" and data.split('-')[1]==\"ok\":\n                 #verificar se o cliente já está na lista de clientes\n                 if clients[addr[0]] is not None:\n                     print(\"confirmação de recepção de multicast recebida de \" + str(addr[0]))\n                     print(\"A atualizar o seu estado para online\")\n@@ -390,8 +390,7 @@\n     gameHandler = Game()\n     networkStatusHandler.start()\n     heartbeatHandler.start()\n     gameHandler.start()\n-    \n \n if __name__ == \"__main__\":\n     main()\n\\ No newline at end of file\n"
                },
                {
                    "date": 1652554244402,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -147,8 +147,9 @@\n             data = data.decode()\n             if data.split('-')[0]==\"heartbeat\":\n                 print(\"Heartbeat recebido de \" + str(addr))\n                 self.setClientOnline(addr[0])\n+                self.socket.sendto(bytes((\"heartbeatOk-%s\"),addr),addr)\n             time.sleep(10)\n             #Verificar se há clientes offline\n             for addr in clients.keys():\n                 if clients[addr][\"online\"]==0:\n"
                },
                {
                    "date": 1652556954289,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -354,12 +354,12 @@\n         gameOptions = self.getOptions(selectedSongs,maxGameRounds)\n         controlCounter = 0\n         filepaths = []\n         filepaths = [self.songList[song][\"filepath\"] for song in selectedSongs]\n-        \n+        self.multiSender(\"loading-\",2)\n         for i in range(0,len(filepaths)):\n             self.multiSender(filepaths[i],0)\n-        self.controlMCast(\"songOk\")\n+            self.controlMCast(\"songOk\")\n         print(\"Musicas enviadas\")\n         self.multiSender(gameOptions,1)\n         self.controlMCast(\"optionsOk\")\n         print(\"Opções Enviadas\")\n"
                }
            ],
            "date": 1652458448350,
            "name": "Commit-0",
            "content": ""
        }
    ]
}