{
    "sourceFile": "master.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 23,
            "patches": [
                {
                    "date": 1649321125937,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1649322079081,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,5 +1,5 @@\n-import socket, sys, threading, json, random, Sender\n+import socket, sys, threading, json, random, Sender, pickle\n \n \n type = sys.argv[1]\n \n@@ -114,21 +114,49 @@\n         controlCounter = 0\n         print(\"Sending song to \" + str(currentGameNumberOfPlayers) + \" players\")\n         #call sender class with ip,port,filepath,socket, where ip is the multicastaddr\n         Sender(self.ip, self.port, fileToSend, self.mCastSocket)         \n+        while controlCounter < currentGameNumberOfPlayers:\n+            data, addr = self.mCastSocket.recvfrom(self.buffer)\n+            if data.decode() == \"song-ok\":\n+                controlCounter += 1\n+        print(\"Song sent to all players\")\n+        controlCounter = 0\n+        self.mCastSocket.sendto(pickle.dumps(choices) (self.ip, self.port))\n+        while controlCounter < currentGameNumberOfPlayers:\n+            data, addr = self.mCastSocket.recvfrom(self.buffer)\n+            if data.decode() == \"choices-ok\":\n+                controlCounter += 1\n+        controlCounter = 0\n+        self.mCastSocket.sendto(b'game-start', (self.ip, self.port))\n+        while controlCounter < currentGameNumberOfPlayers:\n+            data, addr = self.mCastSocket.recvfrom(self.buffer)\n+            if data.decode() == \"game-start-ok\":\n+                controlCounter += 1\n+        results = dict()\n+        while controlCounter < currentGameNumberOfPlayers:\n+            data, addr = self.controlSocket(self.buffer)\n+            if data.split('-')[0] == 'choice':\n+                results[data.split('-')[1]] = data.split('-')[2]\n+        #wait for all players to choose a song and store it in a dictionary as follows:\n+        # {\n+        #   hostname: {\n+        #       choice: songname,\n+        #       addr: address,\n+        #       port: port\n+        #   }\n+        # }\n+        \n \n \n \n-\n-    #select 4 random entrys of songList returning them as an json of artists and titles\n     def getRandomSongs(self):\n-        randomSongs = {}\n+        choices = []\n         for i in range(4):\n             song = random.randint(1,5)\n-            randomSongs.append(self.songList[song][\"artist\"])\n-            randomSongs.append(self.songList[song][\"title\"])\n-        return randomSongs\n-\n+            choices.append(self.songList[song])\n+        return choices\n+    \n     def verifyClientReady(self, hostname):\n \n         if hostname in clients.keys():\n             if clients[hostname][\"ready\"] == 1:\n"
                },
                {
                    "date": 1649323932415,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -134,10 +134,19 @@\n                 controlCounter += 1\n         results = dict()\n         while controlCounter < currentGameNumberOfPlayers:\n             data, addr = self.controlSocket(self.buffer)\n+            ##choice-songname-artist\n             if data.split('-')[0] == 'choice':\n-                results[data.split('-')[1]] = data.split('-')[2]\n+                results[addr] = data.split('-')[2]\n+                print(results)\n+                controlCounter += 1\n+        \n+        #function to get the winner, comparing their choice to the song tittle\n+        winner = self.getWinner(results, selectedSongName, selectedSongArtist)\n+        print(\"The winner is \" + winner)\n+        self.mCastSocket.sendto(b'game-end', (self.ip, self.port))\n+        \n         #wait for all players to choose a song and store it in a dictionary as follows:\n         # {\n         #   hostname: {\n         #       choice: songname,\n@@ -146,10 +155,15 @@\n         #   }\n         # }\n         \n \n+    def getWinner(self, results, selectedSongName, selectedSongArtist):\n+        winners = []\n+        for key, value in results.items():\n+            if value == selectedSongName:\n+                winners.append(key)\n+        return winners\n \n-\n     def getRandomSongs(self):\n         choices = []\n         for i in range(4):\n             song = random.randint(1,5)\n"
                },
                {
                    "date": 1649324154185,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -27,13 +27,10 @@\n \n class gameLogin(threading.Thread):\n     def __init__(self):\n         global clients\n-        self.port = 8080\n-        self.hostName = socket.gethostname()\n-        self.socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n-        self.buffer = 2048\n \n+\n     #Add client based on hostname as key to clients dictionary, if it doesn't exist\n     def addClient(self, hostname, addr, port):\n         if hostname not in clients.keys():\n             clients[hostname] = {\n@@ -94,13 +91,16 @@\n         self.mCastSocket = socket.socket(socket.AF_INET6, socket.SOCK_DGRAM)\n         self.mCastSocket.setsockopt(socket.IPPROTO_IPV6, socket.IPV6_MULTICAST_HOPS, 1)\n         self.mCastSocket.setsockopt(socket.IPPROTO_IPV6, socket.IPV6_MULTICAST_LOOP, 1)\n         self.mCastSocket.bind(('',self.ip))\n-        self.controlSocket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n         self.ip = \"FF02::1\"\n         self.port = 30000\n         self.gameState = 0\n         self.totalPlayers = 0\n+        self.controlPort = 8080\n+        self.hostName = socket.gethostname()\n+        self.controlSocket = socket.socket(socket.AF_INET6, socket.SOCK_DGRAM)\n+        self.buffer = 2048\n \n     def roundHandler(self):\n         #select random number between 1 and 5 to choose a song based on songlist key, where the keys are numbers between 1 and 5\n         song = random.randint(1,5)\n@@ -144,9 +144,11 @@\n         #function to get the winner, comparing their choice to the song tittle\n         winner = self.getWinner(results, selectedSongName, selectedSongArtist)\n         print(\"The winner is \" + winner)\n         self.mCastSocket.sendto(b'game-end', (self.ip, self.port))\n-        \n+        self.mCastSocket.sendto(pickle.dumps(choices),  (self.ip, self.port))\n+        self.gameState = 0\n+        self.totalPlayers = 0\n         #wait for all players to choose a song and store it in a dictionary as follows:\n         # {\n         #   hostname: {\n         #       choice: songname,\n@@ -206,5 +208,6 @@\n             if clients[client][\"ready\"] == 1:\n                 readyPlayers += 1\n         return readyPlayers\n  \n-\n+    def run(self):\n+        while game\n\\ No newline at end of file\n"
                },
                {
                    "date": 1649324262888,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -27,10 +27,13 @@\n \n class gameLogin(threading.Thread):\n     def __init__(self):\n         global clients\n+        self.port = 8080\n+        self.hostName = socket.gethostname()\n+        self.socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n+        self.buffer = 2048\n \n-\n     #Add client based on hostname as key to clients dictionary, if it doesn't exist\n     def addClient(self, hostname, addr, port):\n         if hostname not in clients.keys():\n             clients[hostname] = {\n@@ -91,16 +94,13 @@\n         self.mCastSocket = socket.socket(socket.AF_INET6, socket.SOCK_DGRAM)\n         self.mCastSocket.setsockopt(socket.IPPROTO_IPV6, socket.IPV6_MULTICAST_HOPS, 1)\n         self.mCastSocket.setsockopt(socket.IPPROTO_IPV6, socket.IPV6_MULTICAST_LOOP, 1)\n         self.mCastSocket.bind(('',self.ip))\n+        self.controlSocket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n         self.ip = \"FF02::1\"\n         self.port = 30000\n         self.gameState = 0\n         self.totalPlayers = 0\n-        self.controlPort = 8080\n-        self.hostName = socket.gethostname()\n-        self.controlSocket = socket.socket(socket.AF_INET6, socket.SOCK_DGRAM)\n-        self.buffer = 2048\n \n     def roundHandler(self):\n         #select random number between 1 and 5 to choose a song based on songlist key, where the keys are numbers between 1 and 5\n         song = random.randint(1,5)\n"
                },
                {
                    "date": 1649324591398,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,14 +1,14 @@\n-import socket, sys, threading, json, random, Sender, pickle\n+import socket, threading, json, random, Sender, pickle, time \n \n \n-type = sys.argv[1]\n \n maxPlayersForGame = 3;\n \n \n clients = dict()\n \n+\n #formato mensagens login\n #hello-hostname-join\n #ready-\n \n@@ -99,8 +99,9 @@\n         self.ip = \"FF02::1\"\n         self.port = 30000\n         self.gameState = 0\n         self.totalPlayers = 0\n+        self.currentGameNumberOfPlayers = 0\n \n     def roundHandler(self):\n         #select random number between 1 and 5 to choose a song based on songlist key, where the keys are numbers between 1 and 5\n         song = random.randint(1,5)\n@@ -108,33 +109,33 @@\n         #send the song to the clients\n         fileToSend = self.songList[song][\"filepath\"]\n         selectedSongName = self.songList[song][\"title\"]\n         selectedSongArtist = self.songList[song][\"artist\"]\n-        currentGameNumberOfPlayers = self.getReadyPlayers()\n+        self.currentGameNumberOfPlayers = self.getReadyPlayers()\n         choices = self.getRandomSongs()\n         controlCounter = 0\n-        print(\"Sending song to \" + str(currentGameNumberOfPlayers) + \" players\")\n+        print(\"Sending song to \" + str(self.currentGameNumberOfPlayers) + \" players\")\n         #call sender class with ip,port,filepath,socket, where ip is the multicastaddr\n         Sender(self.ip, self.port, fileToSend, self.mCastSocket)         \n-        while controlCounter < currentGameNumberOfPlayers:\n+        while controlCounter < self.currentGameNumberOfPlayers:\n             data, addr = self.mCastSocket.recvfrom(self.buffer)\n             if data.decode() == \"song-ok\":\n                 controlCounter += 1\n         print(\"Song sent to all players\")\n         controlCounter = 0\n         self.mCastSocket.sendto(pickle.dumps(choices) (self.ip, self.port))\n-        while controlCounter < currentGameNumberOfPlayers:\n+        while controlCounter < self.currentGameNumberOfPlayers:\n             data, addr = self.mCastSocket.recvfrom(self.buffer)\n             if data.decode() == \"choices-ok\":\n                 controlCounter += 1\n         controlCounter = 0\n         self.mCastSocket.sendto(b'game-start', (self.ip, self.port))\n-        while controlCounter < currentGameNumberOfPlayers:\n+        while controlCounter < self.currentGameNumberOfPlayers:\n             data, addr = self.mCastSocket.recvfrom(self.buffer)\n             if data.decode() == \"game-start-ok\":\n                 controlCounter += 1\n         results = dict()\n-        while controlCounter < currentGameNumberOfPlayers:\n+        while controlCounter < self.currentGameNumberOfPlayers:\n             data, addr = self.controlSocket(self.buffer)\n             ##choice-songname-artist\n             if data.split('-')[0] == 'choice':\n                 results[addr] = data.split('-')[2]\n@@ -209,5 +210,7 @@\n                 readyPlayers += 1\n         return readyPlayers\n  \n     def run(self):\n-        while game\n\\ No newline at end of file\n+        while self.currentGameNumberOfPlayers <= maxPlayersForGame:\n+            print(\"Waiting for Players to game!\")\n+            time.sleep(2)\n\\ No newline at end of file\n"
                },
                {
                    "date": 1649324609599,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -212,5 +212,6 @@\n  \n     def run(self):\n         while self.currentGameNumberOfPlayers <= maxPlayersForGame:\n             print(\"Waiting for Players to game!\")\n-            time.sleep(2)\n\\ No newline at end of file\n+            time.sleep(2)\n+        self.roundHandler()\n\\ No newline at end of file\n"
                },
                {
                    "date": 1649324815291,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,5 +1,6 @@\n-import socket, threading, json, random, Sender, pickle, time \n+import socket, threading, json, random, Sender, pickle, time\n+from unicodedata import name \n \n \n \n maxPlayersForGame = 3;\n@@ -213,5 +214,20 @@\n     def run(self):\n         while self.currentGameNumberOfPlayers <= maxPlayersForGame:\n             print(\"Waiting for Players to game!\")\n             time.sleep(2)\n-        self.roundHandler()\n\\ No newline at end of file\n+        self.roundHandler()\n+        \n+        \n+#main function\n+def main():\n+    #start game Login thread\n+    print(\"Starting Game Threads...\\n\")\n+    loginThread = gameLogin()\n+    loginThread.start()\n+    gameThread = gameHandler()\n+    gameThread.start()\n+    \n+if name == '__main__':\n+    main()\n+\n+    \n\\ No newline at end of file\n"
                },
                {
                    "date": 1649328086321,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -32,8 +32,9 @@\n         self.port = 8080\n         self.hostName = socket.gethostname()\n         self.socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n         self.buffer = 2048\n+        self.mCastAddr = \"FF02::1\"\n \n     #Add client based on hostname as key to clients dictionary, if it doesn't exist\n     def addClient(self, hostname, addr, port):\n         if hostname not in clients.keys():\n@@ -68,17 +69,17 @@\n             if data.split('-')[0] == 'hello':\n                 hostname = data.split('-')[1]\n                 if hostname not in clients.keys():\n                     self.addClient(hostname, addr[0], addr[1])\n-                    self.socket.sendto(b'hello-ack-' + hostname.encode(), addr)\n+                    self.socket.sendto(b'hello-ack-' + self.mCastAddr, addr)\n                 else:\n                     self.socket.sendto(b'you are already in the group' + hostname.encode(), addr)\n             elif data.split('-')[0] == 'ready':\n                 hostname = data.split('-')[1]\n                 if hostname in clients.keys():\n                     if clients[hostname]['ready'] == 0:\n                         clients[hostname]['ready'] = 1\n-                        self.socket.sendto(b'ack-' + hostname.encode(), addr)\n+                        self.socket.sendto(b'ready-ack' + hostname.encode(), addr)\n                     else:\n                         self.socket.sendto(b'You are already ready' + hostname.encode(), addr)\n                 else:\n                     self.socket.sendto(b'you are not in the group' + hostname.encode(), addr)\n"
                },
                {
                    "date": 1649333981228,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -118,22 +118,22 @@\n         print(\"Sending song to \" + str(self.currentGameNumberOfPlayers) + \" players\")\n         #call sender class with ip,port,filepath,socket, where ip is the multicastaddr\n         Sender(self.ip, self.port, fileToSend, self.mCastSocket)         \n         while controlCounter < self.currentGameNumberOfPlayers:\n-            data, addr = self.mCastSocket.recvfrom(self.buffer)\n+            data, addr = self.controlSocket.recvfrom(self.buffer)\n             if data.decode() == \"song-ok\":\n                 controlCounter += 1\n         print(\"Song sent to all players\")\n         controlCounter = 0\n         self.mCastSocket.sendto(pickle.dumps(choices) (self.ip, self.port))\n         while controlCounter < self.currentGameNumberOfPlayers:\n-            data, addr = self.mCastSocket.recvfrom(self.buffer)\n+            data, addr = self.controlSocket.recvfrom(self.buffer)\n             if data.decode() == \"choices-ok\":\n                 controlCounter += 1\n         controlCounter = 0\n         self.mCastSocket.sendto(b'game-start', (self.ip, self.port))\n         while controlCounter < self.currentGameNumberOfPlayers:\n-            data, addr = self.mCastSocket.recvfrom(self.buffer)\n+            data, addr = self.controlSocket.recvfrom(self.buffer)\n             if data.decode() == \"game-start-ok\":\n                 controlCounter += 1\n         results = dict()\n         while controlCounter < self.currentGameNumberOfPlayers:\n"
                },
                {
                    "date": 1649424571362,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,234 +1,216 @@\n-import socket, threading, json, random, Sender, pickle, time\n-from unicodedata import name \n+import socket, threading,  json, random, Sender, pickle, time, sys\n \n-\n-\n-maxPlayersForGame = 3;\n-\n-\n+##Global Vars\n clients = dict()\n+maxPlayersForGame = 2\n+totalReadyPlayers = 0\n \n-\n-#formato mensagens login\n-#hello-hostname-join\n-#ready-\n-\n-\"\"\"dicionário clientes\n-    {\n-        hostname: {\n-            addr:ipv6,\n-            port:port,\n-            ready: 0,\n-            ingame: 0/1\n-            },\n-            ...\n-    }\n-\"\"\"\n-\n-\n-class gameLogin(threading.Thread):\n+class controlHandler(threading.Thread):\n     def __init__(self):\n+        threading.Thread.__init__(self)\n         global clients\n         self.port = 8080\n         self.hostName = socket.gethostname()\n-        self.socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n+        #ipv6 socket\n+        self.socket = socket.socket(socket.AF_INET6, socket.SOCK_DGRAM)\n         self.buffer = 2048\n-        self.mCastAddr = \"FF02::1\"\n-\n-    #Add client based on hostname as key to clients dictionary, if it doesn't exist\n-    def addClient(self, hostname, addr, port):\n-        if hostname not in clients.keys():\n-            clients[hostname] = {\n-                \"addr\": addr,\n+        global totalReadyPlayers\n+    \n+    #Adicionar cliente, utilizando o endereço do cliente como chave.\n+    #Caso ele já exista, não faz nada.\n+    def addClient(self, addr, port):\n+        if addr not in clients.keys():\n+            clients[addr] = {\n                 \"port\": port,\n                 \"ready\": 0,\n-                \"ingame\": 0\n+                \"ingame\": 0,\n+                \"online\": 1\n             }\n-            print(\"Client \" + hostname + \" added\")\n+            print(\"Cliente \" + addr + \" adicionado\")\n         else:\n-            print(\"Client \" + hostname + \" already exists\")\n-        return clients[hostname]\n+            print(\"Cliente \" + addr + \" já existe\")\n+        return clients[addr]\n \n-    #Remove client\n-    def removeClient(self, hostname):\n-        if hostname in clients.keys():\n-            clients.pop(hostname)\n-            print(\"Client \" + hostname + \" removed\")\n+    def removeClient(self, addr):\n+        if addr in clients.keys():\n+            clients.pop(addr)\n+            print(\"Cliente \" + addr + \" removido\")\n         else:\n-            print(\"Client \" + hostname + \" not found\")\n-        return clients[hostname]\n-\n-    def handler(self):\n+            print(\"Cliente \" + addr + \" não encontrado\")\n+        return clients[addr]\n+    \n+    def getClient(self, addr):\n+        if addr in clients.keys():\n+            return clients[addr]\n+        else:\n+            print(\"Cliente nao encontrado\")\n+            return None\n+    \n+    def run(self):\n+        global totalReadyPlayers\n+        print(\"In Control Handler\\n\")\n+        self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n         self.socket.bind(('', self.port))\n-        self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n-        self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEPORT, 1)\n-        self.socket.setsockopt(socket.IPPROTO_IPV6, socket.IPV6_MULTICAST_HOPS, 1)\n+        self.mcastAddr = \"FF02::1\"\n         while True:\n-            data,addr = self.socket.recvfrom(self.buffer)\n+            data, addr = self.socket.recvfrom(self.buffer)\n+            data = data.decode()\n             \n-            if data.split('-')[0] == 'hello':\n-                hostname = data.split('-')[1]\n-                if hostname not in clients.keys():\n-                    self.addClient(hostname, addr[0], addr[1])\n-                    self.socket.sendto(b'hello-ack-' + self.mCastAddr, addr)\n+            if data.split('-')[0] == \"hello\":\n+                #verificar se o addr esta presente no dicionario\n+                if addr not in clients.keys():\n+                    self.addClient(addr[0], addr[1])\n+                    self.socket.sendto(bytes(str(\"hello-ack-\"+ str(self.mcastAddr)).encode()), addr)\n                 else:\n-                    self.socket.sendto(b'you are already in the group' + hostname.encode(), addr)\n-            elif data.split('-')[0] == 'ready':\n-                hostname = data.split('-')[1]\n-                if hostname in clients.keys():\n-                    if clients[hostname]['ready'] == 0:\n-                        clients[hostname]['ready'] = 1\n-                        self.socket.sendto(b'ready-ack' + hostname.encode(), addr)\n+                    self.socket.sendto(bytes(\"Cliente ja existente\" + addr.encode()), addr)\n+                print(clients)\n+            \n+            elif data.split('-')[0] == \"ready\":\n+                #verificar se o addr esta presente no dicionario\n+                if addr[0] in clients.keys():\n+                    if clients[addr[0]][\"ready\"] == 0:\n+                        clients[addr[0]][\"ready\"] = 1\n+                        self.socket.sendto(bytes(str(\"ready-ack-\" + str(addr[0])).encode()), addr)\n+                        totalReadyPlayers += 1\n                     else:\n-                        self.socket.sendto(b'You are already ready' + hostname.encode(), addr)\n+                        self.socket.sendto(bytes(str(\"Cliente ja esta pronto\" + addr.encode())), addr)\n                 else:\n-                    self.socket.sendto(b'you are not in the group' + hostname.encode(), addr)\n-    def run(self):\n-        self.handler()\n+                    self.socket.sendto(bytes(str(\"Cliente nao encontrado\" + str(addr[0])).encode()), addr)\n+            elif data.split('-')[0] == \"control\":\n+                #verificar se o addr esta presente no dicionario, dar update ao atributo online para 1\n+                if addr in clients.keys():\n+                    clients[addr[0]][\"online\"] = 1\n+                    self.socket.sendto(bytes(str(\"control-ack\" + addr.encode())), addr)\n+                else:\n+                    self.socket.sendto(bytes(str(\"Cliente nao encontrado\" + str(addr[0])).encode()), addr)\n+            elif data.split('-')[0] == \"disconnect\":\n+                #verificar se o addr esta presente no dicionario, dar update ao atributo online para 0\n+                if addr in clients.keys():\n+                    clients[addr[0]]['online'] = 0\n+                    self.socket.sendto(bytes(\"disconnect-ack\" + addr.encode()), addr)\n+                else:\n+                    self.socket.sendto(bytes(\"Cliente nao encontrado\" + str(addr[0]).encode()), addr)\n+            elif data.split('-')[0] == \"ingame\":\n+                #verificar se o addr esta presente no dicionario, dar update ao atributo online para 1\n+                if addr in clients.keys():\n+                    clients[addr[0]][\"ingame\"] = 1\n+                    self.socket.sendto(bytes(\"ingame-ack\" + addr.encode()), addr)\n+                else:\n+                    self.socket.sendto(bytes(\"Cliente nao encontrado\" + addr.encode()), addr)\n \n \n \n \n class gameHandler(threading.Thread):\n     def __init__(self):\n+        threading.Thread.__init__(self)\n         self.songDB = \"songlist.json\"\n         self.songList = json.load(open(self.songDB))\n         self.mCastSocket = socket.socket(socket.AF_INET6, socket.SOCK_DGRAM)\n-        self.mCastSocket.setsockopt(socket.IPPROTO_IPV6, socket.IPV6_MULTICAST_HOPS, 1)\n+        self.mCastSocket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n+        self.mCastSocket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEPORT,1)\n         self.mCastSocket.setsockopt(socket.IPPROTO_IPV6, socket.IPV6_MULTICAST_LOOP, 1)\n-        self.mCastSocket.bind(('',self.ip))\n-        self.controlSocket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n-        self.ip = \"FF02::1\"\n-        self.port = 30000\n-        self.gameState = 0\n-        self.totalPlayers = 0\n-        self.currentGameNumberOfPlayers = 0\n+        self.mCastSocket.setsockopt(socket.IPPROTO_IPV6, socket.IPV6_MULTICAST_HOPS, 5)\n+        self.mcastPort = 50000\n+        self.mcastAddr = 'FF02::1'\n \n-    def roundHandler(self):\n-        #select random number between 1 and 5 to choose a song based on songlist key, where the keys are numbers between 1 and 5\n-        song = random.randint(1,5)\n-        # go through clients\n-        #send the song to the clients\n-        fileToSend = self.songList[song][\"filepath\"]\n-        selectedSongName = self.songList[song][\"title\"]\n-        selectedSongArtist = self.songList[song][\"artist\"]\n-        self.currentGameNumberOfPlayers = self.getReadyPlayers()\n-        choices = self.getRandomSongs()\n-        controlCounter = 0\n-        print(\"Sending song to \" + str(self.currentGameNumberOfPlayers) + \" players\")\n-        #call sender class with ip,port,filepath,socket, where ip is the multicastaddr\n-        Sender(self.ip, self.port, fileToSend, self.mCastSocket)         \n-        while controlCounter < self.currentGameNumberOfPlayers:\n-            data, addr = self.controlSocket.recvfrom(self.buffer)\n-            if data.decode() == \"song-ok\":\n-                controlCounter += 1\n-        print(\"Song sent to all players\")\n-        controlCounter = 0\n-        self.mCastSocket.sendto(pickle.dumps(choices) (self.ip, self.port))\n-        while controlCounter < self.currentGameNumberOfPlayers:\n-            data, addr = self.controlSocket.recvfrom(self.buffer)\n-            if data.decode() == \"choices-ok\":\n-                controlCounter += 1\n-        controlCounter = 0\n-        self.mCastSocket.sendto(b'game-start', (self.ip, self.port))\n-        while controlCounter < self.currentGameNumberOfPlayers:\n-            data, addr = self.controlSocket.recvfrom(self.buffer)\n-            if data.decode() == \"game-start-ok\":\n-                controlCounter += 1\n-        results = dict()\n-        while controlCounter < self.currentGameNumberOfPlayers:\n-            data, addr = self.controlSocket(self.buffer)\n-            ##choice-songname-artist\n-            if data.split('-')[0] == 'choice':\n-                results[addr] = data.split('-')[2]\n-                print(results)\n-                controlCounter += 1\n-        \n-        #function to get the winner, comparing their choice to the song tittle\n-        winner = self.getWinner(results, selectedSongName, selectedSongArtist)\n-        print(\"The winner is \" + winner)\n\\ No newline at end of file\n-        self.mCastSocket.sendto(b'game-end', (self.ip, self.port))\n-        self.mCastSocket.sendto(pickle.dumps(choices),  (self.ip, self.port))\n-        self.gameState = 0\n-        self.totalPlayers = 0\n-        #wait for all players to choose a song and store it in a dictionary as follows:\n-        # {\n-        #   hostname: {\n-        #       choice: songname,\n-        #       addr: address,\n-        #       port: port\n-        #   }\n-        # }\n-        \n+        self.controlSocket = socket.socket(socket.AF_INET6, socket.SOCK_DGRAM)\n+        self.controlSocket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n+        self.controlPort = 30000\n \n-    def getWinner(self, results, selectedSongName, selectedSongArtist):\n-        winners = []\n-        for key, value in results.items():\n-            if value == selectedSongName:\n-                winners.append(key)\n-        return winners\n+        self.currentGameNumberOfPlayers = 0\n+        global totalReadyPlayers\n+    \n \n-    def getRandomSongs(self):\n-        choices = []\n-        for i in range(4):\n+    def generateGame(self):\n+  \n+        while True:\n             song = random.randint(1,5)\n-            choices.append(self.songList[song])\n-        return choices\n-    \n-    def verifyClientReady(self, hostname):\n+            fileToSend = self.songList[song][\"filepath\"]\n+            selectedSongName = self.songList[song][\"title\"]\n+            selectedSongArtist = self.songList[song][\"artist\"]\n+            self.currentGameNumberOfPlayers = self.getReadyPlayers()\n+            choices = self.getRandomSongs()\n+            controlCounter = 0\n+            print(\"A enviar música para \" + str(self.currentGameNumberOfPlayers) + \" players\")\n+            Sender(self.ip, self.port, fileToSend, self.mCastSocket)\n \n-        if hostname in clients.keys():\n-            if clients[hostname][\"ready\"] == 1:\n-                return True\n-            else:\n-                return False\n-        else:\n-            return False\n+            while controlCounter < self.currentGameNumberOfPlayers:\n+                data, addr = self.controlSocket.recvfrom(self.buffer)\n+                if data.decode() == \"song-ok\":\n+                    controlCounter += 1\n+                print(\"Música enviada para todos os players\")\n+            print(\"Procedendo ao envio das hipóteses de escolha:\")\n+            controlCounter = 0\n+            self.mCastSocket.sendto(pickle.dumps(choices) (self.mcastAddr, self.mcastPort))\n+            \n+            while controlCounter < self.currentGameNumberOfPlayers:\n+                data, addr = self.controlSocket.recvfrom(self.buffer)\n+                if data.decode() == \"choices-ok\":\n+                    controlCounter += 1\n+                    print(\"Hipóteses de escolha enviadas para todos os players\")\n+            controlCounter = 0\n+            \n+            self.mCastSocket.sendto(bytes(\"game-start\", (self.mcastAddr, self.mcastPort)))\n+            while controlCounter < self.currentGameNumberOfPlayers:\n+                data, addr = self.controlSocket.recvfrom(self.buffer)\n+                if data.decode() == \"game-start-ok\":\n+                    controlCounter += 1\n+                    print(\"Jogo iniciado\")\n+            results = dict()\n+            while controlCounter < self.currentGameNumberOfPlayers:\n+                data, addr = self.controlSocket.recvfrom(self.buffer)\n+                if data.split('-')[0] == 'choice':\n+                    results[addr][\"escolha\"] = data.split('-')[1]\n+                    results[addr][\"tempo\"] = data.split('-')[2]\n+                    controlCounter += 1\n+                    print(\"Escolha recebida\")\n+                    self.controlSocket.sendto(bytes(\"choice-ok\", addr))\n+            print(\"Resultados Todos Recebidos:\")\n+            print(results)\n \n-    #Verify if client is in game\n+            winner = self.getWinner(results, selectedSongName)\n+            print(\"O vencedor foi: \" + winner)\n+            self.mCastSocket.sendto(bytes(\"winner-\" + winner[0].encode() + \"-\" + winner[1].encode(), (self.mcastAddr, self.mcastPort)))\n+            print(\"jogo terminado\")\n+            self.currentGameNumberOfPlayers = 0\n+            global totalReadyPlayers \n+            totalReadyPlayers = 0\n \n-    def verifyClientInGame(self, hostname):\n-        if hostname in clients.keys():\n-            if clients[hostname][\"ingame\"] == 1:\n-                return True\n-            else:\n-                return False\n-        else:\n-            return False\n-\n-    #function to get the players that are ready, returning an array containing its addresses\n-    def getReadyPlayersAddr(self):\n-        readyPlayers = []\n-        for client in clients.keys():\n-            if clients[client][\"ready\"] == 1:\n-                readyPlayers.append(clients[client][\"addr\"])\n-        return readyPlayers\n-\n-    #function to get the number of players that are ready\n     def getReadyPlayers(self):\n         readyPlayers = 0\n-        for client in clients.keys():\n-            if clients[client][\"ready\"] == 1:\n+        for client in clients:\n+            if clients[client]['ready'] == 1:\n                 readyPlayers += 1\n         return readyPlayers\n- \n+    \n+    def getRandomSongs(self):\n+        choices = dict()\n+        for client in clients:\n+            if clients[client]['ready'] == 1:\n+                choices[client] = random.randint(1,5)\n+        return choices\n+    \n+    def getWinner(self, results, selectedSongName):\n+        winner = dict()\n+        for client in results:\n+            if results[client][\"escolha\"] == selectedSongName:\n+                winner[client] = results[client][\"tempo\"]\n+        return min(winner, key=winner.get)\n+    \n     def run(self):\n-        while self.currentGameNumberOfPlayers <= maxPlayersForGame:\n-            print(\"Waiting for Players to game!\")\n-            time.sleep(2)\n-        self.roundHandler()\n-        \n-        \n-#main function\n+        global totalReadyPlayers\n+        global maxPlayersForGame\n+        while True:\n+            if totalReadyPlayers == maxPlayersForGame:\n+                self.generateGame()\n+            time.sleep(1)\n+    \n def main():\n-    #start game Login thread\n-    print(\"Starting Game Threads...\\n\")\n-    loginThread = gameLogin()\n-    loginThread.start()\n-    gameThread = gameHandler()\n-    gameThread.start()\n-    \n-if name == '__main__':\n-    main()\n+    controlT = controlHandler()\n+    controlT.start()\n+    gameT = gameHandler()\n+    gameT.start()\n \n-    \n+if __name__ == '__main__':\n+    main()\n\\ No newline at end of file\n"
                },
                {
                    "date": 1649425934123,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -67,30 +67,30 @@\n             \n             elif data.split('-')[0] == \"ready\":\n                 #verificar se o addr esta presente no dicionario\n                 if addr[0] in clients.keys():\n-                    if clients[addr[0]][\"ready\"] == 0:\n-                        clients[addr[0]][\"ready\"] = 1\n-                        self.socket.sendto(bytes(str(\"ready-ack-\" + str(addr[0])).encode()), addr)\n+                    if clients[addr][\"ready\"] == 0:\n+                        clients[addr][\"ready\"] = 1\n+                        self.socket.sendto(bytes(str(\"ready-ack-\" + str(addr).encode()), addr)\n                         totalReadyPlayers += 1\n                     else:\n                         self.socket.sendto(bytes(str(\"Cliente ja esta pronto\" + addr.encode())), addr)\n                 else:\n-                    self.socket.sendto(bytes(str(\"Cliente nao encontrado\" + str(addr[0])).encode()), addr)\n+                    self.socket.sendto(bytes(str(\"Cliente nao encontrado\" + str(addr)).encode()), addr)\n             elif data.split('-')[0] == \"control\":\n                 #verificar se o addr esta presente no dicionario, dar update ao atributo online para 1\n                 if addr in clients.keys():\n                     clients[addr[0]][\"online\"] = 1\n                     self.socket.sendto(bytes(str(\"control-ack\" + addr.encode())), addr)\n                 else:\n-                    self.socket.sendto(bytes(str(\"Cliente nao encontrado\" + str(addr[0])).encode()), addr)\n+                    self.socket.sendto(bytes(str(\"Cliente nao encontrado\" + str(addr)).encode()), addr)\n             elif data.split('-')[0] == \"disconnect\":\n                 #verificar se o addr esta presente no dicionario, dar update ao atributo online para 0\n                 if addr in clients.keys():\n                     clients[addr[0]]['online'] = 0\n                     self.socket.sendto(bytes(\"disconnect-ack\" + addr.encode()), addr)\n                 else:\n-                    self.socket.sendto(bytes(\"Cliente nao encontrado\" + str(addr[0]).encode()), addr)\n+                    self.socket.sendto(bytes(\"Cliente nao encontrado\" + str(addr).encode()), addr)\n             elif data.split('-')[0] == \"ingame\":\n                 #verificar se o addr esta presente no dicionario, dar update ao atributo online para 1\n                 if addr in clients.keys():\n                     clients[addr[0]][\"ingame\"] = 1\n"
                },
                {
                    "date": 1649425996443,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -69,9 +69,9 @@\n                 #verificar se o addr esta presente no dicionario\n                 if addr[0] in clients.keys():\n                     if clients[addr][\"ready\"] == 0:\n                         clients[addr][\"ready\"] = 1\n-                        self.socket.sendto(bytes(str(\"ready-ack-\" + str(addr).encode()), addr)\n+                        self.socket.sendto(bytes(str(\"ready-ack-\" + str(addr).encode())), addr)\n                         totalReadyPlayers += 1\n                     else:\n                         self.socket.sendto(bytes(str(\"Cliente ja esta pronto\" + addr.encode())), addr)\n                 else:\n"
                },
                {
                    "date": 1649426037390,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -58,9 +58,9 @@\n             \n             if data.split('-')[0] == \"hello\":\n                 #verificar se o addr esta presente no dicionario\n                 if addr not in clients.keys():\n-                    self.addClient(addr[0], addr[1])\n+                    self.addClient(addr, addr[1])\n                     self.socket.sendto(bytes(str(\"hello-ack-\"+ str(self.mcastAddr)).encode()), addr)\n                 else:\n                     self.socket.sendto(bytes(\"Cliente ja existente\" + addr.encode()), addr)\n                 print(clients)\n"
                },
                {
                    "date": 1649426134776,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -25,11 +25,11 @@\n                 \"ready\": 0,\n                 \"ingame\": 0,\n                 \"online\": 1\n             }\n-            print(\"Cliente \" + addr + \" adicionado\")\n+            print(\"Cliente \" + str(addr) + \" adicionado\")\n         else:\n-            print(\"Cliente \" + addr + \" já existe\")\n+            print(\"Cliente \" + str(addr) + \" já existe\")\n         return clients[addr]\n \n     def removeClient(self, addr):\n         if addr in clients.keys():\n"
                },
                {
                    "date": 1649426143676,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -33,11 +33,11 @@\n \n     def removeClient(self, addr):\n         if addr in clients.keys():\n             clients.pop(addr)\n-            print(\"Cliente \" + addr + \" removido\")\n+            print(\"Cliente \" + str(addr) + \" removido\")\n         else:\n-            print(\"Cliente \" + addr + \" não encontrado\")\n+            print(\"Cliente \" + str(addr) + \" não encontrado\")\n         return clients[addr]\n     \n     def getClient(self, addr):\n         if addr in clients.keys():\n"
                },
                {
                    "date": 1649426567141,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -71,8 +71,9 @@\n                     if clients[addr][\"ready\"] == 0:\n                         clients[addr][\"ready\"] = 1\n                         self.socket.sendto(bytes(str(\"ready-ack-\" + str(addr).encode())), addr)\n                         totalReadyPlayers += 1\n+                        print(\"Numero total de players à espera: \" + str(totalReadyPlayers))\n                     else:\n                         self.socket.sendto(bytes(str(\"Cliente ja esta pronto\" + addr.encode())), addr)\n                 else:\n                     self.socket.sendto(bytes(str(\"Cliente nao encontrado\" + str(addr)).encode()), addr)\n@@ -201,8 +202,9 @@\n     def run(self):\n         global totalReadyPlayers\n         global maxPlayersForGame\n         while True:\n+            print(\"Waiting to test game\")\n             if totalReadyPlayers == maxPlayersForGame:\n                 self.generateGame()\n             time.sleep(1)\n     \n"
                },
                {
                    "date": 1649426653636,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -202,12 +202,12 @@\n     def run(self):\n         global totalReadyPlayers\n         global maxPlayersForGame\n         while True:\n-            print(\"Waiting to test game\")\n+            print(\"À espera de jogadores suficientes\")\n             if totalReadyPlayers == maxPlayersForGame:\n                 self.generateGame()\n-            time.sleep(1)\n+            time.sleep(5)\n     \n def main():\n     controlT = controlHandler()\n     controlT.start()\n"
                },
                {
                    "date": 1649426709975,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -68,8 +68,9 @@\n             elif data.split('-')[0] == \"ready\":\n                 #verificar se o addr esta presente no dicionario\n                 if addr[0] in clients.keys():\n                     if clients[addr][\"ready\"] == 0:\n+                        print(\"A adicionar ready a um cliente\")\n                         clients[addr][\"ready\"] = 1\n                         self.socket.sendto(bytes(str(\"ready-ack-\" + str(addr).encode())), addr)\n                         totalReadyPlayers += 1\n                         print(\"Numero total de players à espera: \" + str(totalReadyPlayers))\n"
                },
                {
                    "date": 1649426720669,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -71,8 +71,9 @@\n                     if clients[addr][\"ready\"] == 0:\n                         print(\"A adicionar ready a um cliente\")\n                         clients[addr][\"ready\"] = 1\n                         self.socket.sendto(bytes(str(\"ready-ack-\" + str(addr).encode())), addr)\n+                        print(\"A incrementar numero total de players\")\n                         totalReadyPlayers += 1\n                         print(\"Numero total de players à espera: \" + str(totalReadyPlayers))\n                     else:\n                         self.socket.sendto(bytes(str(\"Cliente ja esta pronto\" + addr.encode())), addr)\n"
                },
                {
                    "date": 1649426784607,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -65,8 +65,9 @@\n                     self.socket.sendto(bytes(\"Cliente ja existente\" + addr.encode()), addr)\n                 print(clients)\n             \n             elif data.split('-')[0] == \"ready\":\n+                print(\"Ready Recebio \\n\\n\")\n                 #verificar se o addr esta presente no dicionario\n                 if addr[0] in clients.keys():\n                     if clients[addr][\"ready\"] == 0:\n                         print(\"A adicionar ready a um cliente\")\n"
                },
                {
                    "date": 1649426790907,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -67,9 +67,9 @@\n             \n             elif data.split('-')[0] == \"ready\":\n                 print(\"Ready Recebio \\n\\n\")\n                 #verificar se o addr esta presente no dicionario\n-                if addr[0] in clients.keys():\n+                if addr in clients.keys():\n                     if clients[addr][\"ready\"] == 0:\n                         print(\"A adicionar ready a um cliente\")\n                         clients[addr][\"ready\"] = 1\n                         self.socket.sendto(bytes(str(\"ready-ack-\" + str(addr).encode())), addr)\n"
                },
                {
                    "date": 1649426857374,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -71,9 +71,9 @@\n                 if addr in clients.keys():\n                     if clients[addr][\"ready\"] == 0:\n                         print(\"A adicionar ready a um cliente\")\n                         clients[addr][\"ready\"] = 1\n-                        self.socket.sendto(bytes(str(\"ready-ack-\" + str(addr).encode())), addr)\n+                        self.socket.sendto(bytes(\"ready-ack-\" + str(addr)).encode()), addr)\n                         print(\"A incrementar numero total de players\")\n                         totalReadyPlayers += 1\n                         print(\"Numero total de players à espera: \" + str(totalReadyPlayers))\n                     else:\n"
                },
                {
                    "date": 1649426886697,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -71,9 +71,9 @@\n                 if addr in clients.keys():\n                     if clients[addr][\"ready\"] == 0:\n                         print(\"A adicionar ready a um cliente\")\n                         clients[addr][\"ready\"] = 1\n-                        self.socket.sendto(bytes(\"ready-ack-\" + str(addr)).encode()), addr)\n+                        self.socket.sendto(bytes((\"ready-ack-\" + str(addr)).encode()), addr)\n                         print(\"A incrementar numero total de players\")\n                         totalReadyPlayers += 1\n                         print(\"Numero total de players à espera: \" + str(totalReadyPlayers))\n                     else:\n"
                }
            ],
            "date": 1649321125937,
            "name": "Commit-0",
            "content": "import socket, sys, threading, json, random, Sender\n\n\ntype = sys.argv[1]\n\nmaxPlayersForGame = 3;\n\n\nclients = dict()\n\n#formato mensagens login\n#hello-hostname-join\n#ready-\n\n\"\"\"dicionário clientes\n    {\n        hostname: {\n            addr:ipv6,\n            port:port,\n            ready: 0,\n            ingame: 0/1\n            },\n            ...\n    }\n\"\"\"\n\n\nclass gameLogin(threading.Thread):\n    def __init__(self):\n        global clients\n        self.port = 8080\n        self.hostName = socket.gethostname()\n        self.socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n        self.buffer = 2048\n\n    #Add client based on hostname as key to clients dictionary, if it doesn't exist\n    def addClient(self, hostname, addr, port):\n        if hostname not in clients.keys():\n            clients[hostname] = {\n                \"addr\": addr,\n                \"port\": port,\n                \"ready\": 0,\n                \"ingame\": 0\n            }\n            print(\"Client \" + hostname + \" added\")\n        else:\n            print(\"Client \" + hostname + \" already exists\")\n        return clients[hostname]\n\n    #Remove client\n    def removeClient(self, hostname):\n        if hostname in clients.keys():\n            clients.pop(hostname)\n            print(\"Client \" + hostname + \" removed\")\n        else:\n            print(\"Client \" + hostname + \" not found\")\n        return clients[hostname]\n\n    def handler(self):\n        self.socket.bind(('', self.port))\n        self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n        self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEPORT, 1)\n        self.socket.setsockopt(socket.IPPROTO_IPV6, socket.IPV6_MULTICAST_HOPS, 1)\n        while True:\n            data,addr = self.socket.recvfrom(self.buffer)\n            \n            if data.split('-')[0] == 'hello':\n                hostname = data.split('-')[1]\n                if hostname not in clients.keys():\n                    self.addClient(hostname, addr[0], addr[1])\n                    self.socket.sendto(b'hello-ack-' + hostname.encode(), addr)\n                else:\n                    self.socket.sendto(b'you are already in the group' + hostname.encode(), addr)\n            elif data.split('-')[0] == 'ready':\n                hostname = data.split('-')[1]\n                if hostname in clients.keys():\n                    if clients[hostname]['ready'] == 0:\n                        clients[hostname]['ready'] = 1\n                        self.socket.sendto(b'ack-' + hostname.encode(), addr)\n                    else:\n                        self.socket.sendto(b'You are already ready' + hostname.encode(), addr)\n                else:\n                    self.socket.sendto(b'you are not in the group' + hostname.encode(), addr)\n    def run(self):\n        self.handler()\n\n\n\n\nclass gameHandler(threading.Thread):\n    def __init__(self):\n        self.songDB = \"songlist.json\"\n        self.songList = json.load(open(self.songDB))\n        self.mCastSocket = socket.socket(socket.AF_INET6, socket.SOCK_DGRAM)\n        self.mCastSocket.setsockopt(socket.IPPROTO_IPV6, socket.IPV6_MULTICAST_HOPS, 1)\n        self.mCastSocket.setsockopt(socket.IPPROTO_IPV6, socket.IPV6_MULTICAST_LOOP, 1)\n        self.mCastSocket.bind(('',self.ip))\n        self.controlSocket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n        self.ip = \"FF02::1\"\n        self.port = 30000\n        self.gameState = 0\n        self.totalPlayers = 0\n\n    def roundHandler(self):\n        #select random number between 1 and 5 to choose a song based on songlist key, where the keys are numbers between 1 and 5\n        song = random.randint(1,5)\n        # go through clients\n        #send the song to the clients\n        fileToSend = self.songList[song][\"filepath\"]\n        selectedSongName = self.songList[song][\"title\"]\n        selectedSongArtist = self.songList[song][\"artist\"]\n        currentGameNumberOfPlayers = self.getReadyPlayers()\n        choices = self.getRandomSongs()\n        controlCounter = 0\n        print(\"Sending song to \" + str(currentGameNumberOfPlayers) + \" players\")\n        #call sender class with ip,port,filepath,socket, where ip is the multicastaddr\n        Sender(self.ip, self.port, fileToSend, self.mCastSocket)         \n\n\n\n\n    #select 4 random entrys of songList returning them as an json of artists and titles\n    def getRandomSongs(self):\n        randomSongs = {}\n        for i in range(4):\n            song = random.randint(1,5)\n            randomSongs.append(self.songList[song][\"artist\"])\n            randomSongs.append(self.songList[song][\"title\"])\n        return randomSongs\n\n    def verifyClientReady(self, hostname):\n\n        if hostname in clients.keys():\n            if clients[hostname][\"ready\"] == 1:\n                return True\n            else:\n                return False\n        else:\n            return False\n\n    #Verify if client is in game\n\n    def verifyClientInGame(self, hostname):\n        if hostname in clients.keys():\n            if clients[hostname][\"ingame\"] == 1:\n                return True\n            else:\n                return False\n        else:\n            return False\n\n    #function to get the players that are ready, returning an array containing its addresses\n    def getReadyPlayersAddr(self):\n        readyPlayers = []\n        for client in clients.keys():\n            if clients[client][\"ready\"] == 1:\n                readyPlayers.append(clients[client][\"addr\"])\n        return readyPlayers\n\n    #function to get the number of players that are ready\n    def getReadyPlayers(self):\n        readyPlayers = 0\n        for client in clients.keys():\n            if clients[client][\"ready\"] == 1:\n                readyPlayers += 1\n        return readyPlayers\n \n\n"
        }
    ]
}