{
    "sourceFile": "master.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 9,
            "patches": [
                {
                    "date": 1649321125937,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1649322079081,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,5 +1,5 @@\n-import socket, sys, threading, json, random, Sender\n+import socket, sys, threading, json, random, Sender, pickle\n \n \n type = sys.argv[1]\n \n@@ -114,21 +114,49 @@\n         controlCounter = 0\n         print(\"Sending song to \" + str(currentGameNumberOfPlayers) + \" players\")\n         #call sender class with ip,port,filepath,socket, where ip is the multicastaddr\n         Sender(self.ip, self.port, fileToSend, self.mCastSocket)         \n+        while controlCounter < currentGameNumberOfPlayers:\n+            data, addr = self.mCastSocket.recvfrom(self.buffer)\n+            if data.decode() == \"song-ok\":\n+                controlCounter += 1\n+        print(\"Song sent to all players\")\n+        controlCounter = 0\n+        self.mCastSocket.sendto(pickle.dumps(choices) (self.ip, self.port))\n+        while controlCounter < currentGameNumberOfPlayers:\n+            data, addr = self.mCastSocket.recvfrom(self.buffer)\n+            if data.decode() == \"choices-ok\":\n+                controlCounter += 1\n+        controlCounter = 0\n+        self.mCastSocket.sendto(b'game-start', (self.ip, self.port))\n+        while controlCounter < currentGameNumberOfPlayers:\n+            data, addr = self.mCastSocket.recvfrom(self.buffer)\n+            if data.decode() == \"game-start-ok\":\n+                controlCounter += 1\n+        results = dict()\n+        while controlCounter < currentGameNumberOfPlayers:\n+            data, addr = self.controlSocket(self.buffer)\n+            if data.split('-')[0] == 'choice':\n+                results[data.split('-')[1]] = data.split('-')[2]\n+        #wait for all players to choose a song and store it in a dictionary as follows:\n+        # {\n+        #   hostname: {\n+        #       choice: songname,\n+        #       addr: address,\n+        #       port: port\n+        #   }\n+        # }\n+        \n \n \n \n-\n-    #select 4 random entrys of songList returning them as an json of artists and titles\n     def getRandomSongs(self):\n-        randomSongs = {}\n+        choices = []\n         for i in range(4):\n             song = random.randint(1,5)\n-            randomSongs.append(self.songList[song][\"artist\"])\n-            randomSongs.append(self.songList[song][\"title\"])\n-        return randomSongs\n-\n+            choices.append(self.songList[song])\n+        return choices\n+    \n     def verifyClientReady(self, hostname):\n \n         if hostname in clients.keys():\n             if clients[hostname][\"ready\"] == 1:\n"
                },
                {
                    "date": 1649323932415,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -134,10 +134,19 @@\n                 controlCounter += 1\n         results = dict()\n         while controlCounter < currentGameNumberOfPlayers:\n             data, addr = self.controlSocket(self.buffer)\n+            ##choice-songname-artist\n             if data.split('-')[0] == 'choice':\n-                results[data.split('-')[1]] = data.split('-')[2]\n+                results[addr] = data.split('-')[2]\n+                print(results)\n+                controlCounter += 1\n+        \n+        #function to get the winner, comparing their choice to the song tittle\n+        winner = self.getWinner(results, selectedSongName, selectedSongArtist)\n+        print(\"The winner is \" + winner)\n+        self.mCastSocket.sendto(b'game-end', (self.ip, self.port))\n+        \n         #wait for all players to choose a song and store it in a dictionary as follows:\n         # {\n         #   hostname: {\n         #       choice: songname,\n@@ -146,10 +155,15 @@\n         #   }\n         # }\n         \n \n+    def getWinner(self, results, selectedSongName, selectedSongArtist):\n+        winners = []\n+        for key, value in results.items():\n+            if value == selectedSongName:\n+                winners.append(key)\n+        return winners\n \n-\n     def getRandomSongs(self):\n         choices = []\n         for i in range(4):\n             song = random.randint(1,5)\n"
                },
                {
                    "date": 1649324154185,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -27,13 +27,10 @@\n \n class gameLogin(threading.Thread):\n     def __init__(self):\n         global clients\n-        self.port = 8080\n-        self.hostName = socket.gethostname()\n-        self.socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n-        self.buffer = 2048\n \n+\n     #Add client based on hostname as key to clients dictionary, if it doesn't exist\n     def addClient(self, hostname, addr, port):\n         if hostname not in clients.keys():\n             clients[hostname] = {\n@@ -94,13 +91,16 @@\n         self.mCastSocket = socket.socket(socket.AF_INET6, socket.SOCK_DGRAM)\n         self.mCastSocket.setsockopt(socket.IPPROTO_IPV6, socket.IPV6_MULTICAST_HOPS, 1)\n         self.mCastSocket.setsockopt(socket.IPPROTO_IPV6, socket.IPV6_MULTICAST_LOOP, 1)\n         self.mCastSocket.bind(('',self.ip))\n-        self.controlSocket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n         self.ip = \"FF02::1\"\n         self.port = 30000\n         self.gameState = 0\n         self.totalPlayers = 0\n+        self.controlPort = 8080\n+        self.hostName = socket.gethostname()\n+        self.controlSocket = socket.socket(socket.AF_INET6, socket.SOCK_DGRAM)\n+        self.buffer = 2048\n \n     def roundHandler(self):\n         #select random number between 1 and 5 to choose a song based on songlist key, where the keys are numbers between 1 and 5\n         song = random.randint(1,5)\n@@ -144,9 +144,11 @@\n         #function to get the winner, comparing their choice to the song tittle\n         winner = self.getWinner(results, selectedSongName, selectedSongArtist)\n         print(\"The winner is \" + winner)\n         self.mCastSocket.sendto(b'game-end', (self.ip, self.port))\n-        \n+        self.mCastSocket.sendto(pickle.dumps(choices),  (self.ip, self.port))\n+        self.gameState = 0\n+        self.totalPlayers = 0\n         #wait for all players to choose a song and store it in a dictionary as follows:\n         # {\n         #   hostname: {\n         #       choice: songname,\n@@ -206,5 +208,6 @@\n             if clients[client][\"ready\"] == 1:\n                 readyPlayers += 1\n         return readyPlayers\n  \n-\n+    def run(self):\n+        while game\n\\ No newline at end of file\n"
                },
                {
                    "date": 1649324262888,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -27,10 +27,13 @@\n \n class gameLogin(threading.Thread):\n     def __init__(self):\n         global clients\n+        self.port = 8080\n+        self.hostName = socket.gethostname()\n+        self.socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n+        self.buffer = 2048\n \n-\n     #Add client based on hostname as key to clients dictionary, if it doesn't exist\n     def addClient(self, hostname, addr, port):\n         if hostname not in clients.keys():\n             clients[hostname] = {\n@@ -91,16 +94,13 @@\n         self.mCastSocket = socket.socket(socket.AF_INET6, socket.SOCK_DGRAM)\n         self.mCastSocket.setsockopt(socket.IPPROTO_IPV6, socket.IPV6_MULTICAST_HOPS, 1)\n         self.mCastSocket.setsockopt(socket.IPPROTO_IPV6, socket.IPV6_MULTICAST_LOOP, 1)\n         self.mCastSocket.bind(('',self.ip))\n+        self.controlSocket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n         self.ip = \"FF02::1\"\n         self.port = 30000\n         self.gameState = 0\n         self.totalPlayers = 0\n-        self.controlPort = 8080\n-        self.hostName = socket.gethostname()\n-        self.controlSocket = socket.socket(socket.AF_INET6, socket.SOCK_DGRAM)\n-        self.buffer = 2048\n \n     def roundHandler(self):\n         #select random number between 1 and 5 to choose a song based on songlist key, where the keys are numbers between 1 and 5\n         song = random.randint(1,5)\n"
                },
                {
                    "date": 1649324591398,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,14 +1,14 @@\n-import socket, sys, threading, json, random, Sender, pickle\n+import socket, threading, json, random, Sender, pickle, time \n \n \n-type = sys.argv[1]\n \n maxPlayersForGame = 3;\n \n \n clients = dict()\n \n+\n #formato mensagens login\n #hello-hostname-join\n #ready-\n \n@@ -99,8 +99,9 @@\n         self.ip = \"FF02::1\"\n         self.port = 30000\n         self.gameState = 0\n         self.totalPlayers = 0\n+        self.currentGameNumberOfPlayers = 0\n \n     def roundHandler(self):\n         #select random number between 1 and 5 to choose a song based on songlist key, where the keys are numbers between 1 and 5\n         song = random.randint(1,5)\n@@ -108,33 +109,33 @@\n         #send the song to the clients\n         fileToSend = self.songList[song][\"filepath\"]\n         selectedSongName = self.songList[song][\"title\"]\n         selectedSongArtist = self.songList[song][\"artist\"]\n-        currentGameNumberOfPlayers = self.getReadyPlayers()\n+        self.currentGameNumberOfPlayers = self.getReadyPlayers()\n         choices = self.getRandomSongs()\n         controlCounter = 0\n-        print(\"Sending song to \" + str(currentGameNumberOfPlayers) + \" players\")\n+        print(\"Sending song to \" + str(self.currentGameNumberOfPlayers) + \" players\")\n         #call sender class with ip,port,filepath,socket, where ip is the multicastaddr\n         Sender(self.ip, self.port, fileToSend, self.mCastSocket)         \n-        while controlCounter < currentGameNumberOfPlayers:\n+        while controlCounter < self.currentGameNumberOfPlayers:\n             data, addr = self.mCastSocket.recvfrom(self.buffer)\n             if data.decode() == \"song-ok\":\n                 controlCounter += 1\n         print(\"Song sent to all players\")\n         controlCounter = 0\n         self.mCastSocket.sendto(pickle.dumps(choices) (self.ip, self.port))\n-        while controlCounter < currentGameNumberOfPlayers:\n+        while controlCounter < self.currentGameNumberOfPlayers:\n             data, addr = self.mCastSocket.recvfrom(self.buffer)\n             if data.decode() == \"choices-ok\":\n                 controlCounter += 1\n         controlCounter = 0\n         self.mCastSocket.sendto(b'game-start', (self.ip, self.port))\n-        while controlCounter < currentGameNumberOfPlayers:\n+        while controlCounter < self.currentGameNumberOfPlayers:\n             data, addr = self.mCastSocket.recvfrom(self.buffer)\n             if data.decode() == \"game-start-ok\":\n                 controlCounter += 1\n         results = dict()\n-        while controlCounter < currentGameNumberOfPlayers:\n+        while controlCounter < self.currentGameNumberOfPlayers:\n             data, addr = self.controlSocket(self.buffer)\n             ##choice-songname-artist\n             if data.split('-')[0] == 'choice':\n                 results[addr] = data.split('-')[2]\n@@ -209,5 +210,7 @@\n                 readyPlayers += 1\n         return readyPlayers\n  \n     def run(self):\n-        while game\n\\ No newline at end of file\n+        while self.currentGameNumberOfPlayers <= maxPlayersForGame:\n+            print(\"Waiting for Players to game!\")\n+            time.sleep(2)\n\\ No newline at end of file\n"
                },
                {
                    "date": 1649324609599,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -212,5 +212,6 @@\n  \n     def run(self):\n         while self.currentGameNumberOfPlayers <= maxPlayersForGame:\n             print(\"Waiting for Players to game!\")\n-            time.sleep(2)\n\\ No newline at end of file\n+            time.sleep(2)\n+        self.roundHandler()\n\\ No newline at end of file\n"
                },
                {
                    "date": 1649324815291,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,5 +1,6 @@\n-import socket, threading, json, random, Sender, pickle, time \n+import socket, threading, json, random, Sender, pickle, time\n+from unicodedata import name \n \n \n \n maxPlayersForGame = 3;\n@@ -213,5 +214,20 @@\n     def run(self):\n         while self.currentGameNumberOfPlayers <= maxPlayersForGame:\n             print(\"Waiting for Players to game!\")\n             time.sleep(2)\n-        self.roundHandler()\n\\ No newline at end of file\n+        self.roundHandler()\n+        \n+        \n+#main function\n+def main():\n+    #start game Login thread\n+    print(\"Starting Game Threads...\\n\")\n+    loginThread = gameLogin()\n+    loginThread.start()\n+    gameThread = gameHandler()\n+    gameThread.start()\n+    \n+if name == '__main__':\n+    main()\n+\n+    \n\\ No newline at end of file\n"
                },
                {
                    "date": 1649328086321,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -32,8 +32,9 @@\n         self.port = 8080\n         self.hostName = socket.gethostname()\n         self.socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n         self.buffer = 2048\n+        self.mCastAddr = \"FF02::1\"\n \n     #Add client based on hostname as key to clients dictionary, if it doesn't exist\n     def addClient(self, hostname, addr, port):\n         if hostname not in clients.keys():\n@@ -68,17 +69,17 @@\n             if data.split('-')[0] == 'hello':\n                 hostname = data.split('-')[1]\n                 if hostname not in clients.keys():\n                     self.addClient(hostname, addr[0], addr[1])\n-                    self.socket.sendto(b'hello-ack-' + hostname.encode(), addr)\n+                    self.socket.sendto(b'hello-ack-' + self.mCastAddr, addr)\n                 else:\n                     self.socket.sendto(b'you are already in the group' + hostname.encode(), addr)\n             elif data.split('-')[0] == 'ready':\n                 hostname = data.split('-')[1]\n                 if hostname in clients.keys():\n                     if clients[hostname]['ready'] == 0:\n                         clients[hostname]['ready'] = 1\n-                        self.socket.sendto(b'ack-' + hostname.encode(), addr)\n+                        self.socket.sendto(b'ready-ack' + hostname.encode(), addr)\n                     else:\n                         self.socket.sendto(b'You are already ready' + hostname.encode(), addr)\n                 else:\n                     self.socket.sendto(b'you are not in the group' + hostname.encode(), addr)\n"
                },
                {
                    "date": 1649333981228,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -118,22 +118,22 @@\n         print(\"Sending song to \" + str(self.currentGameNumberOfPlayers) + \" players\")\n         #call sender class with ip,port,filepath,socket, where ip is the multicastaddr\n         Sender(self.ip, self.port, fileToSend, self.mCastSocket)         \n         while controlCounter < self.currentGameNumberOfPlayers:\n-            data, addr = self.mCastSocket.recvfrom(self.buffer)\n+            data, addr = self.controlSocket.recvfrom(self.buffer)\n             if data.decode() == \"song-ok\":\n                 controlCounter += 1\n         print(\"Song sent to all players\")\n         controlCounter = 0\n         self.mCastSocket.sendto(pickle.dumps(choices) (self.ip, self.port))\n         while controlCounter < self.currentGameNumberOfPlayers:\n-            data, addr = self.mCastSocket.recvfrom(self.buffer)\n+            data, addr = self.controlSocket.recvfrom(self.buffer)\n             if data.decode() == \"choices-ok\":\n                 controlCounter += 1\n         controlCounter = 0\n         self.mCastSocket.sendto(b'game-start', (self.ip, self.port))\n         while controlCounter < self.currentGameNumberOfPlayers:\n-            data, addr = self.mCastSocket.recvfrom(self.buffer)\n+            data, addr = self.controlSocket.recvfrom(self.buffer)\n             if data.decode() == \"game-start-ok\":\n                 controlCounter += 1\n         results = dict()\n         while controlCounter < self.currentGameNumberOfPlayers:\n"
                }
            ],
            "date": 1649321125937,
            "name": "Commit-0",
            "content": "import socket, sys, threading, json, random, Sender\n\n\ntype = sys.argv[1]\n\nmaxPlayersForGame = 3;\n\n\nclients = dict()\n\n#formato mensagens login\n#hello-hostname-join\n#ready-\n\n\"\"\"dicionário clientes\n    {\n        hostname: {\n            addr:ipv6,\n            port:port,\n            ready: 0,\n            ingame: 0/1\n            },\n            ...\n    }\n\"\"\"\n\n\nclass gameLogin(threading.Thread):\n    def __init__(self):\n        global clients\n        self.port = 8080\n        self.hostName = socket.gethostname()\n        self.socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n        self.buffer = 2048\n\n    #Add client based on hostname as key to clients dictionary, if it doesn't exist\n    def addClient(self, hostname, addr, port):\n        if hostname not in clients.keys():\n            clients[hostname] = {\n                \"addr\": addr,\n                \"port\": port,\n                \"ready\": 0,\n                \"ingame\": 0\n            }\n            print(\"Client \" + hostname + \" added\")\n        else:\n            print(\"Client \" + hostname + \" already exists\")\n        return clients[hostname]\n\n    #Remove client\n    def removeClient(self, hostname):\n        if hostname in clients.keys():\n            clients.pop(hostname)\n            print(\"Client \" + hostname + \" removed\")\n        else:\n            print(\"Client \" + hostname + \" not found\")\n        return clients[hostname]\n\n    def handler(self):\n        self.socket.bind(('', self.port))\n        self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n        self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEPORT, 1)\n        self.socket.setsockopt(socket.IPPROTO_IPV6, socket.IPV6_MULTICAST_HOPS, 1)\n        while True:\n            data,addr = self.socket.recvfrom(self.buffer)\n            \n            if data.split('-')[0] == 'hello':\n                hostname = data.split('-')[1]\n                if hostname not in clients.keys():\n                    self.addClient(hostname, addr[0], addr[1])\n                    self.socket.sendto(b'hello-ack-' + hostname.encode(), addr)\n                else:\n                    self.socket.sendto(b'you are already in the group' + hostname.encode(), addr)\n            elif data.split('-')[0] == 'ready':\n                hostname = data.split('-')[1]\n                if hostname in clients.keys():\n                    if clients[hostname]['ready'] == 0:\n                        clients[hostname]['ready'] = 1\n                        self.socket.sendto(b'ack-' + hostname.encode(), addr)\n                    else:\n                        self.socket.sendto(b'You are already ready' + hostname.encode(), addr)\n                else:\n                    self.socket.sendto(b'you are not in the group' + hostname.encode(), addr)\n    def run(self):\n        self.handler()\n\n\n\n\nclass gameHandler(threading.Thread):\n    def __init__(self):\n        self.songDB = \"songlist.json\"\n        self.songList = json.load(open(self.songDB))\n        self.mCastSocket = socket.socket(socket.AF_INET6, socket.SOCK_DGRAM)\n        self.mCastSocket.setsockopt(socket.IPPROTO_IPV6, socket.IPV6_MULTICAST_HOPS, 1)\n        self.mCastSocket.setsockopt(socket.IPPROTO_IPV6, socket.IPV6_MULTICAST_LOOP, 1)\n        self.mCastSocket.bind(('',self.ip))\n        self.controlSocket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n        self.ip = \"FF02::1\"\n        self.port = 30000\n        self.gameState = 0\n        self.totalPlayers = 0\n\n    def roundHandler(self):\n        #select random number between 1 and 5 to choose a song based on songlist key, where the keys are numbers between 1 and 5\n        song = random.randint(1,5)\n        # go through clients\n        #send the song to the clients\n        fileToSend = self.songList[song][\"filepath\"]\n        selectedSongName = self.songList[song][\"title\"]\n        selectedSongArtist = self.songList[song][\"artist\"]\n        currentGameNumberOfPlayers = self.getReadyPlayers()\n        choices = self.getRandomSongs()\n        controlCounter = 0\n        print(\"Sending song to \" + str(currentGameNumberOfPlayers) + \" players\")\n        #call sender class with ip,port,filepath,socket, where ip is the multicastaddr\n        Sender(self.ip, self.port, fileToSend, self.mCastSocket)         \n\n\n\n\n    #select 4 random entrys of songList returning them as an json of artists and titles\n    def getRandomSongs(self):\n        randomSongs = {}\n        for i in range(4):\n            song = random.randint(1,5)\n            randomSongs.append(self.songList[song][\"artist\"])\n            randomSongs.append(self.songList[song][\"title\"])\n        return randomSongs\n\n    def verifyClientReady(self, hostname):\n\n        if hostname in clients.keys():\n            if clients[hostname][\"ready\"] == 1:\n                return True\n            else:\n                return False\n        else:\n            return False\n\n    #Verify if client is in game\n\n    def verifyClientInGame(self, hostname):\n        if hostname in clients.keys():\n            if clients[hostname][\"ingame\"] == 1:\n                return True\n            else:\n                return False\n        else:\n            return False\n\n    #function to get the players that are ready, returning an array containing its addresses\n    def getReadyPlayersAddr(self):\n        readyPlayers = []\n        for client in clients.keys():\n            if clients[client][\"ready\"] == 1:\n                readyPlayers.append(clients[client][\"addr\"])\n        return readyPlayers\n\n    #function to get the number of players that are ready\n    def getReadyPlayers(self):\n        readyPlayers = 0\n        for client in clients.keys():\n            if clients[client][\"ready\"] == 1:\n                readyPlayers += 1\n        return readyPlayers\n \n\n"
        }
    ]
}